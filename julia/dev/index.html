<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantumGrav.jl · QuantumGrav.jl</title><meta name="title" content="QuantumGrav.jl · QuantumGrav.jl"/><meta property="og:title" content="QuantumGrav.jl · QuantumGrav.jl"/><meta property="twitter:title" content="QuantumGrav.jl · QuantumGrav.jl"/><meta name="description" content="Documentation for QuantumGrav.jl."/><meta property="og:description" content="Documentation for QuantumGrav.jl."/><meta property="twitter:description" content="Documentation for QuantumGrav.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>QuantumGrav.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>QuantumGrav.jl</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started"><span>Getting Started</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Configuration"><span>Configuration</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>QuantumGrav.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>QuantumGrav.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ssciwr/QuantumGrav" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="ssciwr/QuantumGrav" title="Edit source"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantumGrav.jl"><a class="docs-heading-anchor" href="#QuantumGrav.jl">QuantumGrav.jl</a><a id="QuantumGrav.jl-1"></a><a class="docs-heading-anchor-permalink" href="#QuantumGrav.jl" title="Permalink"></a></h1><h2 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h2><p>This package provides functionality to generate csets of different types. Currently, it only supports 2D causal sets in general. The package builds on <a href="https://www.thphys.uni-heidelberg.de/~hollmeier/causalsets/">CausalSets.jl</a>.</p><p>Currently supported are:</p><ul><li>simply connected manifold like causal sets based on analytical manifolds</li><li>manifold like csets with complex, branched connections</li><li>random: Causal sets with randomly selected links</li><li>layered: Causal sets in which events are ordered in layers along the time dimension.</li><li>merged: A merger of a random and manifold like causal set</li><li>destroyed: A manifold like causal set with some edges being flipped, which makes it a non-manifold like causal set.</li><li>grid like: Causal sets in which events are ordered in a grid like fashion according to a certain scheme, which can be one of &#39;quadratic&#39;, &#39;rectangular&#39;, &#39;rhombic&#39;, &#39;hexagonal&#39;, &#39;oblique&#39;</li></ul><p>You currently have to install the package from the github repository directly:</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(url = &quot;https://github.com/ssciwr/QuantumGrav.git&quot;, subdir=&quot;QuantumGrav.jl&quot;)</code></pre><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>The main entry point for cset generation is the <code>CsetFactory</code> struct. This is constructed from a configuration dictionary that can be read from disk. The configuration can be stored in any kind of file that results in a nested dictionary as described below, but YAML is the most common and typically prefered format.</p><pre><code class="language-julia hljs">import QuantumGrav as QG
import YAML
config = _YAML.load_file(joinpath(&quot;path&quot;, &quot;to&quot;, &quot;configfile.yaml&quot;)) # load from yaml file.
csetfactory = QG.CsetFactory(config)</code></pre><p>Once an instance of this struct is created, you can construct a new cset via:</p><pre><code class="language-julia hljs">cset = csetfactory((
    &quot;random&quot;, # a cset type as described above
    1000, # number of events in the cset
))</code></pre><p>This will return a causal set of the requested size and kind of the type <code>CausalSets.BitArrayCauset</code>.</p><p>This package uses the zarr format for storing data to file. From a constructed cset, a multitude of observables can be derived. These can be stored in a dictionary that then can be written directly into a zarr file. Secondly, a helper function is provided to copy the config and the source code used to generate the observables to the same directory as the data and creates a Zarr <code>DirectoryStore</code> there. This helps with reproducibility and documentation of different data generation runs. The created Zarr file will contain the pid of the generating process and the date and time in <code>yyyy-mm-dd_HH-MM-SS</code> format.</p><p>We first define a function that takes a Causal Set factory and builds a dictionary of computed observables:</p><pre><code class="language-julia hljs">import QuantumGrav as QG
import Random
import Zarr

function make_cset_data(csetfactory)
    cset = csetfactory(
        &quot;random&quot;, # a cset type as described above
        1000, # number of events in the cset
    )

    return Dict(
        &quot;observable1&quot; =&gt; make_observable1(cset) # assume the `make_observable1` would be user defined
        &quot;observable2&quot; =&gt; make_observable2(cset)
    )
end</code></pre><p>Then we load the config and call the <code>prepare_dataproduction</code> function to set everything up. The second argument will serve as an anchor to determine which source code files shall be copied over. In this case, it will be the file where the <code>make_cset_data</code> function is defined. If you add other functions, their respective sourcecode files will be copied as well.</p><pre><code class="language-julia hljs">config = _YAML.load_file(joinpath(&quot;path&quot;, &quot;to&quot;, &quot;configfile.yaml&quot;)) # load from yaml file.

path_to_store, zarr_store = QG.prepare_dataproduction(
    config,
    [make_cset_data];
    nameaddition = &quot;random_data&quot;, # will create a folder starting with &#39;random_data&#39; and ending with &#39;.zarr&#39;
)

# make the factory
factory = QG.CsetFactory(config)</code></pre><p>Finally, we create our data. This can also be parallelized with <code>Threads.@threads</code>, <code>Distributed.@distributed</code>, <code>Distributed.pmap</code> or in other ways.</p><pre><code class="language-julia hljs">for i in 1:num_csets
    data = Dict(&quot;cset_$i&quot;=&gt; make_cset_data(factory))
    QG.dict_to_zarr(file, data)
end</code></pre><p>The whole procedure will result in a directory <code>output/random_data_{pid}_{yyyy-mm-dd_HH-MM-SS}.zarr</code>, which contains directories <code>cset_{i}</code> and therein the respective observables.</p><p>The resulting directory structure will look like this:</p><pre><code class="nohighlight hljs">output/
└── random_data_12345_2025-11-13_14-30-45.zarr/
    ├── .zattrs                    # Zarr metadata
    ├── .zgroup                    # Zarr group marker
    ├── config.yaml                # Copy of configuration used
    ├── make_cset_data.jl          # Source code snapshot
    ├── ...                        # other sourcecode files
    ├── cset_1/
    │   ├── .zgroup
    │   ├── observable1/           # Arrays stored as Zarr arrays
    │   │   ├── .zarray
    │   │   └── ...
    │   └── observable2/
    │       ├── .zarray
    │       └── ...
    ├── cset_2/
    │   ├── .zgroup
    │   ├── observable1/
    │   └── observable2/
    │
    ├── ...                        # more csets
    └── cset_N/
        ├── .zgroup
        ├── observable1/
        └── observable2/</code></pre><h2 id="Configuration"><a class="docs-heading-anchor" href="#Configuration">Configuration</a><a id="Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Configuration" title="Permalink"></a></h2><p>The causal set factories each come with a specific configuration dictionary that is validated by JSON schemas. Each cset type requires specific distribution parameters that control the stochastic generation process.</p><h3 id="Top-Level-Configuration"><a class="docs-heading-anchor" href="#Top-Level-Configuration">Top-Level Configuration</a><a id="Top-Level-Configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Top-Level-Configuration" title="Permalink"></a></h3><p>The main <code>CsetFactory</code> configuration requires:</p><ul><li><strong><code>seed</code></strong> (integer): Random seed for reproducibility</li><li><strong><code>num_datapoints</code></strong> (integer, ≥0): Number of data points to generate</li><li><strong><code>csetsize_distr</code></strong> (string): Name of distribution for causet sizes (e.g., &quot;DiscreteUniform&quot;)</li><li><strong><code>csetsize_distr_args</code></strong> (array of integers): Arguments for the size distribution</li><li><strong><code>csetsize_distr_kwargs</code></strong> (object, optional): Keyword arguments for the size distribution</li><li><strong><code>cset_type</code></strong> (string or array of strings): Type(s) of causets to generate (see below)</li><li><strong><code>output</code></strong> (string): Output file path</li></ul><p>Plus nested configurations for each cset type (see below).</p><h3 id="Polynomial-Manifold-Configuration-(polynomial)"><a class="docs-heading-anchor" href="#Polynomial-Manifold-Configuration-(polynomial)">Polynomial Manifold Configuration (<code>polynomial</code>)</a><a id="Polynomial-Manifold-Configuration-(polynomial)-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-Manifold-Configuration-(polynomial)" title="Permalink"></a></h3><p>Required fields:</p><ul><li><strong><code>order_distribution</code></strong> (string): Distribution name for polynomial order (must yield integers)</li><li><strong><code>order_distribution_args</code></strong> (array of integers): Distribution arguments</li><li><strong><code>order_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>r_distribution</code></strong> (string): Distribution name for exponential decay parameter</li><li><strong><code>r_distribution_args</code></strong> (array of numbers): Distribution arguments (must be &gt; 1)</li><li><strong><code>r_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">config[&quot;polynomial&quot;] = Dict(
    &quot;order_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
    &quot;order_distribution_args&quot; =&gt; [3, 10],
    &quot;order_distribution_kwargs&quot; =&gt; Dict(),
    &quot;r_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;r_distribution_args&quot; =&gt; [1.5, 3.0],
    &quot;r_distribution_kwargs&quot; =&gt; Dict()
)</code></pre><h3 id="Layered-Configuration-(layered)"><a class="docs-heading-anchor" href="#Layered-Configuration-(layered)">Layered Configuration (<code>layered</code>)</a><a id="Layered-Configuration-(layered)-1"></a><a class="docs-heading-anchor-permalink" href="#Layered-Configuration-(layered)" title="Permalink"></a></h3><p>Required fields:</p><ul><li><strong><code>connectivity_distribution</code></strong> (string): Distribution for connectivity probability between layers</li><li><strong><code>connectivity_distribution_args</code></strong> (array of numbers): Distribution arguments (should be in [0,1])</li><li><strong><code>connectivity_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>stddev_distribution</code></strong> (string): Distribution for Gaussian standard deviation in layer sizes</li><li><strong><code>stddev_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>stddev_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>layer_distribution</code></strong> (string): Distribution for number of layers</li><li><strong><code>layer_distribution_args</code></strong> (array of integers): Distribution arguments</li><li><strong><code>layer_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">config[&quot;layered&quot;] = Dict(
    &quot;connectivity_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;connectivity_distribution_args&quot; =&gt; [0.3, 0.7],
    &quot;connectivity_distribution_kwargs&quot; =&gt; Dict(),
    &quot;stddev_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;stddev_distribution_args&quot; =&gt; [5.0, 20.0],
    &quot;stddev_distribution_kwargs&quot; =&gt; Dict(),
    &quot;layer_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
    &quot;layer_distribution_args&quot; =&gt; [3, 10],
    &quot;layer_distribution_kwargs&quot; =&gt; Dict()
)</code></pre><h3 id="Random-(Connectivity-Based)-Configuration-(random)"><a class="docs-heading-anchor" href="#Random-(Connectivity-Based)-Configuration-(random)">Random (Connectivity-Based) Configuration (<code>random</code>)</a><a id="Random-(Connectivity-Based)-Configuration-(random)-1"></a><a class="docs-heading-anchor-permalink" href="#Random-(Connectivity-Based)-Configuration-(random)" title="Permalink"></a></h3><p>Required fields:</p><ul><li><strong><code>connectivity_distribution</code></strong> (string): Distribution for target connectivity ratio</li><li><strong><code>connectivity_distribution_args</code></strong> (array of numbers): Distribution arguments (should be in (0,1])</li><li><strong><code>connectivity_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>max_iter</code></strong> (integer, ≥1): Maximum MCMC iterations per attempt</li><li><strong><code>num_tries</code></strong> (integer, ≥1): Number of attempts before giving up</li><li><strong><code>abs_tol</code></strong> (number or null): Absolute tolerance for convergence (use <code>null</code> if using <code>rel_tol</code>)</li><li><strong><code>rel_tol</code></strong> (number or null): Relative tolerance for convergence (use <code>null</code> if using <code>abs_tol</code>)</li></ul><p><strong>Note:</strong> Exactly one of <code>abs_tol</code> or <code>rel_tol</code> should be non-null.</p><p><strong>Example:</strong></p><pre><code class="language-julia hljs">config[&quot;random&quot;] = Dict(
    &quot;connectivity_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;connectivity_distribution_args&quot; =&gt; [0.1, 0.9],
    &quot;connectivity_distribution_kwargs&quot; =&gt; Dict(),
    &quot;max_iter&quot; =&gt; 10000,
    &quot;num_tries&quot; =&gt; 3,
    &quot;abs_tol&quot; =&gt; 0.01,
    &quot;rel_tol&quot; =&gt; nothing
)</code></pre><h3 id="Destroyed-Configuration-(destroyed)"><a class="docs-heading-anchor" href="#Destroyed-Configuration-(destroyed)">Destroyed Configuration (<code>destroyed</code>)</a><a id="Destroyed-Configuration-(destroyed)-1"></a><a class="docs-heading-anchor-permalink" href="#Destroyed-Configuration-(destroyed)" title="Permalink"></a></h3><p>Required fields:</p><ul><li><strong><code>order_distribution</code></strong> (string): Distribution for polynomial order (integers)</li><li><strong><code>order_distribution_args</code></strong> (array of integers): Distribution arguments</li><li><strong><code>order_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>r_distribution</code></strong> (string): Distribution for exponential decay parameter</li><li><strong><code>r_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>r_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>flip_distribution</code></strong> (string): Distribution for fraction of edges to flip</li><li><strong><code>flip_distribution_args</code></strong> (array of numbers): Distribution arguments (typically in [0,1])</li><li><strong><code>flip_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">config[&quot;destroyed&quot;] = Dict(
    &quot;order_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
    &quot;order_distribution_args&quot; =&gt; [3, 8],
    &quot;order_distribution_kwargs&quot; =&gt; Dict(),
    &quot;r_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;r_distribution_args&quot; =&gt; [1.5, 2.5],
    &quot;r_distribution_kwargs&quot; =&gt; Dict(),
    &quot;flip_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;flip_distribution_args&quot; =&gt; [0.05, 0.3],
    &quot;flip_distribution_kwargs&quot; =&gt; Dict()
)</code></pre><h3 id="Grid-Configuration-(grid)"><a class="docs-heading-anchor" href="#Grid-Configuration-(grid)">Grid Configuration (<code>grid</code>)</a><a id="Grid-Configuration-(grid)-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-Configuration-(grid)" title="Permalink"></a></h3><p>Required fields (similar to polynomial, plus grid-specific):</p><ul><li><strong><code>grid_distribution</code></strong> (string): Distribution for grid type index</li><li><strong><code>grid_distribution_args</code></strong> (array of integers): Distribution arguments</li><li><strong><code>grid_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>rotate_distribution</code></strong> (string): Distribution for rotation angle (degrees)</li><li><strong><code>rotate_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>rotate_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>order_distribution</code></strong>, <strong><code>r_distribution</code></strong>: Same as polynomial configuration</li></ul><p>Grid types: &#39;quadratic&#39;, &#39;rectangular&#39;, &#39;rhombic&#39;, &#39;hexagonal&#39;, &#39;oblique&#39;. Each grid type has their own parameters.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">config[&quot;grid&quot;] = Dict(
        &quot;grid_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
        &quot;grid_distribution_args&quot; =&gt; [1, 6],
        &quot;grid_distribution_kwargs&quot; =&gt; Dict(),
        &quot;rotate_distribution&quot; =&gt; &quot;Uniform&quot;,
        &quot;rotate_distribution_args&quot; =&gt; [0.0, 180.0],
        &quot;rotate_distribution_kwargs&quot; =&gt; Dict(),
        &quot;order_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
        &quot;order_distribution_args&quot; =&gt; [2, 8],
        &quot;order_distribution_kwargs&quot; =&gt; Dict(),
        &quot;r_distribution&quot; =&gt; &quot;Uniform&quot;,
        &quot;r_distribution_args&quot; =&gt; [4.0, 8.0],
        &quot;r_distribution_kwargs&quot; =&gt; Dict(),
        &quot;quadratic&quot; =&gt; Dict(), # nothing needed here
        &quot;rectangular&quot; =&gt; Dict(
            &quot;segment_ratio_distribution&quot; =&gt; &quot;Beta&quot;,
            &quot;segment_ratio_distribution_args&quot; =&gt; [2.0, 1.2],
            &quot;segment_ratio_distribution_kwargs&quot; =&gt; Dict(),
        ),
        &quot;rhombic&quot; =&gt; Dict(
            &quot;segment_ratio_distribution&quot; =&gt; &quot;Uniform&quot;,
            &quot;segment_ratio_distribution_args&quot; =&gt; [0.5, 5.5],
            &quot;segment_ratio_distribution_kwargs&quot; =&gt; Dict(),
        ),
        &quot;hexagonal&quot; =&gt; Dict(
            &quot;segment_ratio_distribution&quot; =&gt; &quot;Normal&quot;,
            &quot;segment_ratio_distribution_args&quot; =&gt; [2.0, 0.5],
            &quot;segment_ratio_distribution_kwargs&quot; =&gt; Dict(),
        ),
        &quot;triangular&quot; =&gt; Dict(
            &quot;segment_ratio_distribution&quot; =&gt; &quot;Normal&quot;,
            &quot;segment_ratio_distribution_args&quot; =&gt; [3.3, 1.2],
            &quot;segment_ratio_distribution_kwargs&quot; =&gt; Dict(),
        ),
        &quot;oblique&quot; =&gt; Dict(
            &quot;segment_ratio_distribution&quot; =&gt; &quot;Logistic&quot;,
            &quot;segment_ratio_distribution_args&quot; =&gt; [2.0, 1.0],
            &quot;segment_ratio_distribution_kwargs&quot; =&gt; Dict(),
            &quot;oblique_angle_distribution&quot; =&gt; &quot;Normal&quot;,
            &quot;oblique_angle_distribution_args&quot; =&gt; [45.0, 15.0],
            &quot;oblique_angle_distribution_kwargs&quot; =&gt; Dict(),
        ),
    )</code></pre><h3 id="Merged-Configuration-(merged)"><a class="docs-heading-anchor" href="#Merged-Configuration-(merged)">Merged Configuration (<code>merged</code>)</a><a id="Merged-Configuration-(merged)-1"></a><a class="docs-heading-anchor-permalink" href="#Merged-Configuration-(merged)" title="Permalink"></a></h3><p>Required fields:</p><ul><li><strong><code>order_distribution</code></strong>, <strong><code>r_distribution</code></strong>: For the manifold component</li><li><strong><code>link_prob_distribution</code></strong> (string): Distribution for cross-insertion link probability</li><li><strong><code>link_prob_distribution_args</code></strong> (array of numbers): Distribution arguments (in [0,1])</li><li><strong><code>link_prob_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>n2_rel_distribution</code></strong> (string): Distribution for relative size of inserted component</li><li><strong><code>n2_rel_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>n2_rel_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>connectivity_distribution</code></strong> (string): Distribution for connectivity of inserted random component</li><li><strong><code>connectivity_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>connectivity_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">config[&quot;merged&quot;] = Dict(
            &quot;order_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
            &quot;order_distribution_args&quot; =&gt; [2, 8],
            &quot;order_distribution_kwargs&quot; =&gt; Dict(),
            &quot;r_distribution&quot; =&gt; &quot;Normal&quot;,
            &quot;r_distribution_args&quot; =&gt; [4.0, 2.0],
            &quot;r_distribution_kwargs&quot; =&gt; Dict(),
            &quot;n2_rel_distribution&quot; =&gt; &quot;Uniform&quot;,
            &quot;n2_rel_distribution_args&quot; =&gt; [0., 1.0],
            &quot;n2_rel_distribution_kwargs&quot; =&gt; Dict(),
            &quot;connectivity_distribution&quot; =&gt; &quot;Beta&quot;,
            &quot;connectivity_distribution_args&quot; =&gt; [0.5, 0.1],
            &quot;connectivity_distribution_kwargs&quot; =&gt; Dict(),
            &quot;link_prob_distribution&quot; =&gt; &quot;Normal&quot;,
            &quot;link_prob_distribution_args&quot; =&gt; [2.0, 1.5],
            &quot;link_prob_distribution_kwargs&quot; =&gt; Dict(),
)</code></pre><h3 id="Complex-Topology-Configuration-(complex_topology)"><a class="docs-heading-anchor" href="#Complex-Topology-Configuration-(complex_topology)">Complex Topology Configuration (<code>complex_topology</code>)</a><a id="Complex-Topology-Configuration-(complex_topology)-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Topology-Configuration-(complex_topology)" title="Permalink"></a></h3><p>Required fields:</p><ul><li><strong><code>order_distribution</code></strong>, <strong><code>r_distribution</code></strong>: For the base manifold</li><li><strong><code>vertical_cut_distribution</code></strong> (string): Distribution for number of vertical (timelike) cuts</li><li><strong><code>vertical_cut_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>vertical_cut_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>finite_cut_distribution</code></strong> (string): Distribution for number of finite (mixed) cuts</li><li><strong><code>finite_cut_distribution_args</code></strong> (array of numbers): Distribution arguments</li><li><strong><code>finite_cut_distribution_kwargs</code></strong> (object, optional): Distribution keyword arguments</li><li><strong><code>tol</code></strong> (number): Floating point tolerance for geometric comparisons</li></ul><p><strong>Example:</strong></p><pre><code class="language-julia hljs">config[&quot;complex_topology&quot;] = Dict(
    &quot;order_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
    &quot;order_distribution_args&quot; =&gt; [3, 8],
    &quot;order_distribution_kwargs&quot; =&gt; Dict(),
    &quot;r_distribution&quot; =&gt; &quot;Uniform&quot;,
    &quot;r_distribution_args&quot; =&gt; [1.5, 2.5],
    &quot;r_distribution_kwargs&quot; =&gt; Dict(),
    &quot;vertical_cut_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
    &quot;vertical_cut_distribution_args&quot; =&gt; [0, 3],
    &quot;vertical_cut_distribution_kwargs&quot; =&gt; Dict(),
    &quot;finite_cut_distribution&quot; =&gt; &quot;DiscreteUniform&quot;,
    &quot;finite_cut_distribution_args&quot; =&gt; [0, 2],
    &quot;finite_cut_distribution_kwargs&quot; =&gt; Dict(),
    &quot;tol&quot; =&gt; 1e-12
)</code></pre><h3 id="Distribution-Specification"><a class="docs-heading-anchor" href="#Distribution-Specification">Distribution Specification</a><a id="Distribution-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Distribution-Specification" title="Permalink"></a></h3><p>All distributions use the pattern:</p><ul><li><code>&lt;name&gt;_distribution</code>: String name of a univariate distribution from <code>Distributions.jl</code> (e.g., &quot;Uniform&quot;, &quot;Normal&quot;, &quot;DiscreteUniform&quot;)</li><li><code>&lt;name&gt;_distribution_args</code>: Positional arguments as array (e.g., <code>[min, max]</code> for Uniform)</li><li><code>&lt;name&gt;_distribution_kwargs</code>: Optional keyword arguments as dictionary. Usually not needed.</li></ul><p>Common distributions:</p><ul><li><strong>Uniform(a, b)</strong>: Continuous uniform on [a, b]</li><li><strong>Normal(μ, σ)</strong>: Normal with mean μ and std σ</li><li><strong>DiscreteUniform(a, b)</strong>: Discrete uniform on {a, a+1, ..., b}</li></ul><p>See the <a href="https://juliastats.org/Distributions.jl/stable/univariate/">documentation of Distributions.jl</a> for all available distributions and their needed parameters</p><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>A Julia package for generating and manipulating causal sets for quantum gravity research.</p><h3 id="Causal-Set-Generation"><a class="docs-heading-anchor" href="#Causal-Set-Generation">Causal Set Generation</a><a id="Causal-Set-Generation-1"></a><a class="docs-heading-anchor-permalink" href="#Causal-Set-Generation" title="Permalink"></a></h3><h5 id="Manifold-like-Causal-Sets"><a class="docs-heading-anchor" href="#Manifold-like-Causal-Sets">Manifold-like Causal Sets</a><a id="Manifold-like-Causal-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Manifold-like-Causal-Sets" title="Permalink"></a></h5><p>Generate causal sets by sprinkling points into polynomial manifolds:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.make_polynomial_manifold_cset"><a class="docstring-binding" href="#QuantumGrav.make_polynomial_manifold_cset"><code>QuantumGrav.make_polynomial_manifold_cset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_polynomial_manifold_cset(npoints::Int64, rng::Random.AbstractRNG, order::Int64, r::Float64, d::Int64=2, type::Type{T}=Float32)::Tuple{CausalSets.BitArrayCauset,Vector{Tuple{T, Vargarg{T}}},Matrix{T}} where {T&lt;:Number}</code></pre><p>Generate a causal set by sampling from a positive polynomial constructed via a truncated  Chebyshev series with exponentially decaying coefficients.</p><p><strong>Arguments</strong></p><ul><li><code>npoints::Int</code>: Number of elements to sprinkle into the causal set. Must be &gt; 0.</li><li><code>seed::Int</code>: Seed for pseudo-random number generation to ensure reproducibility.</li><li><code>order::Int</code>: Truncation order of the Chebyshev expansion (number of basis functions in each direction). Must be &gt; 0.</li><li><code>r::Float64</code>: Decay base for Chebyshev coefficients. Must be &gt; 1 to ensure exponential convergence; defines the radius of analyticity in the complex plane.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>d::Int64</code>: Dimension of the manifold, defaults to 2. Currently, only 2D is supported.</li><li><code>type::Type{T}</code>: Type to which the sprinkling coordinates will be converted (default is Float32).</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(cset, sprinkling, chebyshev_coefs)</code> where:<ul><li><code>cset</code>: The generated causal set.</li><li><code>sprinkling</code>: The list of sprinkled points.</li><li><code>chebyshev_coefs</code>: The matrix of Chebyshev coefficients used to construct the manifold.</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>npoints &lt;= 0</code></li><li><code>ArgumentError</code> if <code>order &lt;= 0</code></li><li><code>ArgumentError</code> if <code>r &lt;= 1</code></li><li><code>ArgumentError</code> if <code>d != 2</code>. Currently, only 2D is supported.</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h5 id="Layered-Causal-Sets"><a class="docs-heading-anchor" href="#Layered-Causal-Sets">Layered Causal Sets</a><a id="Layered-Causal-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Layered-Causal-Sets" title="Permalink"></a></h5><p>Generate layered causal sets with controlled connectivity between layers:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.gaussian_dist_cuts"><a class="docstring-binding" href="#QuantumGrav.gaussian_dist_cuts"><code>QuantumGrav.gaussian_dist_cuts</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gaussian_dist_cuts(N, n, σ; rng=Random.GLOBAL_RNG)</code></pre><p>Create cut points between layers drawn from a Gaussian distribution centered on equal partition sizes.</p><p>Inputs:     N :: Int — total number of elements to partition     n :: Int — number of layers     σ :: Float64 — standard deviation for Gaussian offsets from equal partitioning     rng :: AbstractRNG — random number generator (default: Random.GLOBAL_RNG)</p><p>Returns:     cuts :: Vector{Int} — list of cut indices separating layers (length n-1)</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.create_random_layered_causet"><a class="docstring-binding" href="#QuantumGrav.create_random_layered_causet"><code>QuantumGrav.create_random_layered_causet</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">layered_causet(N, n; p=0.5, rng=Random.GLOBAL_RNG)</code></pre><p>Generate an n-layered causal set with N elements, randomly partitioned into n layers, with each potential link between adjacent layers included independently with probability p. Layer sizes are drawn from a Gaussian distribution  centered around equal partition size.</p><p>Inputs:     N :: Int — total number of elements in the causal set     n :: Int — number of layers     p :: Float64 — probability for a link to exist between elements in successive layers     rng :: AbstractRNG — random number generator to use (default: Random.GLOBAL<em>RNG)     standard</em>deviation :: Float64: standard deviation of the Gaussian around equal partitioning</p><p>Returns:     tcg :: BitArrayCauset - randomly produced layered causal set     atoms<em>per</em>layer :: Vector{Int64} - number of atoms per layer sorted from past to future</p><p>Notes:     The <code>standard_deviation</code> keyword controls the spread of the Gaussian in partitioning; if not provided, defaults to <code>0.1 * N / n</code>.     Layer sizes are resampled until within bounds to avoid bias from clamping.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h5 id="Connectivity-Based-Sampling"><a class="docs-heading-anchor" href="#Connectivity-Based-Sampling">Connectivity-Based Sampling</a><a id="Connectivity-Based-Sampling-1"></a><a class="docs-heading-anchor-permalink" href="#Connectivity-Based-Sampling" title="Permalink"></a></h5><p>Sample causal sets targeting specific connectivity values:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.sample_bitarray_causet_by_connectivity"><a class="docstring-binding" href="#QuantumGrav.sample_bitarray_causet_by_connectivity"><code>QuantumGrav.sample_bitarray_causet_by_connectivity</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Sample a causet with given connectivity using a Markov Chain Monte Carlo method with adaptive number of edge flips.</p><p><strong>Parameters</strong></p><ul><li><code>size::Int64</code>: Number of nodes in the causet.</li><li><code>connectivity_goal::Float64</code>: Target connectivity ratio for the causet.</li><li><code>markov_steps::Int64</code>: Number of Markov chain steps to perform.</li><li><code>rng::AbstractRNG</code>: Random number generator instance.</li><li><code>flips_param::Float64</code>: Parameter of algorithm that relates distance from connectivity goal with number of edge flips.</li><li><code>rel_tol::Float64</code>: Relative distance between connectivity and connectivity_goal beyond which the algorithm stops.</li><li><code>abs_tol::Float64</code>: Absolute distance between connectivity and connectivity_goal beyond which the algorithm stops.</li><li><code>acceptance::Float64</code>: Acceptance parameter for the Metropolis criterion.</li></ul><p><strong>Returns</strong></p><ul><li>A bitarray causet sampled according to the connectivity goal.</li><li>A boolean indicating whether the sampling was successful.</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.random_causet_by_connectivity_distribution"><a class="docstring-binding" href="#QuantumGrav.random_causet_by_connectivity_distribution"><code>QuantumGrav.random_causet_by_connectivity_distribution</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Sample a causet of given <code>size</code> with connectivity goal drawn from a specified distribution.</p><p>This function draws a connectivity goal value from the provided distribution <code>dist</code> and then  samples a causet using Markov Chain Monte Carlo with adaptive edge flips to approximate this connectivity.</p><p><strong>Inputs</strong></p><ul><li><code>size::Int64</code>: Number of nodes in the causet.</li><li><code>dist::Distributions.Distribution</code>: Distribution from which to draw the connectivity goal.</li><li><code>markov_steps::Int64</code>: Number of Markov chain steps to perform.</li><li><code>rng::Random.AbstractRNG</code>: Random number generator instance.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>rel_tol::Union{Float64,Nothing}</code>: Relative tolerance for stopping criterion.</li><li><code>abs_tol::Union{Float64,Nothing}</code>: Absolute tolerance for stopping criterion.</li><li><code>acceptance::Float64</code>: Acceptance parameter for the Metropolis criterion.</li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing:<ul><li><code>CausalSets.BitArrayCauset</code>: The sampled causet as a bitarray.</li><li><code>Bool</code>: A boolean indicating whether the sampling was successful within the tolerance.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h5 id="Grid-like-Causal-Sets"><a class="docs-heading-anchor" href="#Grid-like-Causal-Sets">Grid-like Causal Sets</a><a id="Grid-like-Causal-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-like-Causal-Sets" title="Permalink"></a></h5><p>Generate regular grid structures in causal sets:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.generate_grid_from_brillouin_cell"><a class="docstring-binding" href="#QuantumGrav.generate_grid_from_brillouin_cell"><code>QuantumGrav.generate_grid_from_brillouin_cell</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">generate_grid_from_brillouin_cell(num_atoms, edges; origin=nothing) -&gt; Vector{CausalSets.Coordinates{N}}</code></pre><p>Construct an N‑dimensional regular grid of approximately <code>num_atoms</code> points that fills the Brillouin cell spanned by <code>N</code> edge vectors <code>edges</code>.</p><p><strong>Arguments</strong></p><ul><li><code>num_atoms::Int</code>: desired number of grid points (≥1). The implementation lays down a Cartesian parameter grid with ≈ <code>num_atoms</code> candidates and trims to exactly <code>num_atoms</code>.</li><li><code>edges::NTuple{N,CausalSets.Coordinates{N}}</code>: the <code>N</code> spanning edge vectors of a <em>parallelepiped</em> cell. Points are of the form <code>x = origin + sum_i t_i * edges[i]</code> with <code>t_i ∈ [0,1]</code>.</li><li><code>origin</code>: optional <code>NTuple{N,Float64}</code> origin (vertex) of the cell. If <code>nothing</code>, zero is used.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{CausalSets.Coordinates{N}}</code>: grid points inside the cell, ordered lexicographically in the parameter tuple <code>(t₁,…,t_N)</code>, trimmed to length <code>num_atoms</code>.</li></ul><p><strong>Errors</strong></p><ul><li>Throws <code>ArgumentError</code> if <code>num_atoms &lt; 1</code>.</li><li>Throws <code>ArgumentError</code> if the <code>edges</code> are not linearly independent (near‑zero determinant).</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.generate_grid_2d"><a class="docstring-binding" href="#QuantumGrav.generate_grid_2d"><code>QuantumGrav.generate_grid_2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">generate_grid_2d(num_atoms, lattice; a=1.0, b=0.5, gamma_deg=60.0, rotate_deg=nothing, origin=(0.0,0.0))
    -&gt; Vector{CausalSets.Coordinates{2}}</code></pre><p>Wrapper that builds a 2D Bravais cell from a lattice name and calls <code>generate_grid_from_brillouin_cell</code> to return <code>num_atoms</code> points.</p><p>Supported <code>lattice</code> names (case‑insensitive, with aliases):</p><ul><li>&quot;square&quot;, &quot;quadratic&quot;:         edges <code>((a,0), (0,a))</code></li><li>&quot;rectangular&quot;:                  edges <code>((a,0), (0,b))</code></li><li>&quot;centered-rectangular&quot;, &quot;rhombic&quot;, &quot;c-rect&quot;: primitive edges <code>((a/2,b/2), (a/2,-b/2))</code></li><li>&quot;hexagonal&quot;, &quot;triangular&quot;:      edges <code>((a,0), (a/2, a*sqrt(3)/2))</code></li><li>&quot;oblique&quot;, &quot;monoclinic&quot;:       edges <code>((a,0), (b*cosγ, b*sinγ))</code>, with <code>γ = gamma_deg</code> (degrees)</li></ul><p><strong>Keywords</strong></p><ul><li><code>a::Float64=1.0</code>, <code>b::Float64=0.5</code>: lattice constants (for square, only <code>a</code> is used).</li><li><code>gamma_deg::Float64=60.0</code>: angle (degrees) between edges for the oblique lattice.</li><li><code>rotate_deg=nothing</code>: rotation (degrees) applied to the basis before grid generation. If <code>nothing</code>, an automatic rotation aligns the net growth direction <code>e₁+e₂</code> with <code>+y</code>.</li><li><code>origin::CausalSets.Coordinates{2}=(0.0,0.0)</code>: origin (vertex) of the cell.</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.create_grid_causet_2D"><a class="docstring-binding" href="#QuantumGrav.create_grid_causet_2D"><code>QuantumGrav.create_grid_causet_2D</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_grid_causet_2D(size, lattice, manifold; 
                      type=Float32, a=1.0, b=0.5, 
                      gamma_deg=60.0, rotate_deg=nothing, 
                      origin=(0.0, 0.0)) 
    -&gt; Tuple{CausalSets.BitArrayCauset, Bool, Matrix{T}}</code></pre><p>Construct a 2D grid of <code>size</code> points based on the given Bravais lattice, sort them by the time function of <code>manifold</code>, and build a <code>BitArrayCauset</code> from the resulting pseudo‑sprinkling.</p><p><strong>Arguments</strong></p><ul><li><code>size::Int</code>: number of atoms to generate (≥ 1).</li><li><code>lattice::AbstractString</code>: name of the 2D Bravais lattice. Supported names (case-insensitive):   • &quot;square&quot;, &quot;quadratic&quot; → edges ((a,0), (0,a))   • &quot;rectangular&quot; → edges ((a,0), (0,b))   • &quot;centered-rectangular&quot;, &quot;rhombic&quot;, &quot;c-rect&quot; → edges ((a/2,b/2), (a/2,-b/2))   • &quot;hexagonal&quot;, &quot;triangular&quot; → edges ((a,0), (a/2, a<em>sqrt(3)/2))   • &quot;oblique&quot;, &quot;monoclinic&quot; → edges ((a,0), (b</em>cos(γ), b*sin(γ))) with <code>γ = gamma_deg</code></li><li><code>manifold::CausalSets.AbstractManifold{2}</code>: 2D manifold defining the causal structure on the grid.</li></ul><p><strong>Keywords</strong></p><ul><li><code>type::Type{T}=Float32</code>: numeric type used for the returned coordinate matrix.</li><li><code>a::Float64=1.0</code>, <code>b::Float64=0.5</code>: lattice constants.</li><li><code>gamma_deg::Float64=60.0</code>: angle between lattice vectors (for &quot;oblique&quot;/&quot;monoclinic&quot; only).</li><li><code>rotate_deg=nothing</code>: if set, rotate the lattice by the given angle (in degrees). If <code>nothing</code>, automatically aligns <code>(e₁ + e₂)</code> with the positive y-axis.</li><li><code>origin::Tuple{Float64,Float64}</code>: coordinate of the origin vertex.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{BitArrayCauset, Bool, Matrix{T}}</code>:    <ul><li><code>BitArrayCauset</code> the constructed causet,</li><li><code>Bool</code> - <code>true</code> immitates the &quot;converged&quot; return option for random_csets</li><li><code>Matrix{T}</code> - the coordinate matrix of atoms on the grid, immitating the pseudo-sprinkling in random_csets</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.create_grid_causet_2D_polynomial_manifold"><a class="docstring-binding" href="#QuantumGrav.create_grid_causet_2D_polynomial_manifold"><code>QuantumGrav.create_grid_causet_2D_polynomial_manifold</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_grid_causet_2D_polynomial_manifold(size, lattice, rng, order, r;
                                          type=Float32, a=1.0, b=0.5, 
                                          gamma_deg=60.0, rotate_deg=nothing, 
                                          origin=(0.0, 0.0)) 
    -&gt; Tuple{CausalSets.BitArrayCauset, Bool, Matrix{T}}</code></pre><p>Construct a 2D grid of <code>size</code> points based on the given Bravais lattice, generate a random 2D polynomial time function, and build a <code>BitArrayCauset</code> from the resulting pseudo-sprinkling order.</p><p><strong>Arguments</strong></p><ul><li><code>size::Int</code>: number of atoms to generate (≥ 1).</li><li><code>lattice::AbstractString</code>: name of the 2D Bravais lattice. Supported names (case-insensitive):   • &quot;square&quot;, &quot;quadratic&quot; → edges ((a,0), (0,a))   • &quot;rectangular&quot; → edges ((a,0), (0,b))   • &quot;centered-rectangular&quot;, &quot;rhombic&quot;, &quot;c-rect&quot; → edges ((a/2,b/2), (a/2,-b/2))   • &quot;hexagonal&quot;, &quot;triangular&quot; → edges ((a,0), (a/2, a<em>sqrt(3)/2))   • &quot;oblique&quot;, &quot;monoclinic&quot; → edges ((a,0), (b</em>cos(γ), b*sin(γ))) with <code>γ = gamma_deg</code></li><li><code>rng::Random.AbstractRNG</code>: random number generator for coefficient sampling.</li><li><code>order::Int</code>: order of the polynomial (≥ 1).</li><li><code>r::Float64</code>: exponential decay rate for Chebyshev coefficients.</li></ul><p><strong>Keywords</strong></p><ul><li><code>type::Type{T}=Float32</code>: numeric type used for the returned coordinate matrix.</li><li><code>a::Float64=1.0</code>, <code>b::Float64=0.5</code>: lattice constants.</li><li><code>gamma_deg::Float64=60.0</code>: angle between lattice vectors (for &quot;oblique&quot;/&quot;monoclinic&quot; only).</li><li><code>rotate_deg=nothing</code>: if set, rotate the lattice by the given angle (in degrees). If <code>nothing</code>, automatically aligns <code>(e₁ + e₂)</code> with the positive y-axis.</li><li><code>origin::Tuple{Float64,Float64}</code>: coordinate of the origin vertex.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{BitArrayCauset, Bool, Matrix{T}}</code>:    <ul><li><code>BitArrayCauset</code> — the constructed causet from the polynomial time ordering,</li><li><code>Bool</code> — always <code>true</code>, for compatibility</li><li><code>Matrix{T}</code> — coordinate matrix of atoms on the grid.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h5 id="Branched-Manifold-Causal-Sets"><a class="docs-heading-anchor" href="#Branched-Manifold-Causal-Sets">Branched Manifold Causal Sets</a><a id="Branched-Manifold-Causal-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Branched-Manifold-Causal-Sets" title="Permalink"></a></h5><p>Generate causal sets with complex topological features:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.BranchedManifoldCauset"><a class="docstring-binding" href="#QuantumGrav.BranchedManifoldCauset"><code>QuantumGrav.BranchedManifoldCauset</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BranchedManifoldCauset{N, M} &lt;: CausalSets.AbstractCauset</code></pre><p>A causal set embedded in a background manifold with topological branch points (cuts), supporting finite and boundary-connecting cut segments.</p><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: Dimensionality of the spacetime.</li><li><code>M</code>: Type of the background manifold (a subtype of <code>CausalSets.AbstractManifold{N}</code>).</li></ul><p><strong>Fields</strong></p><ul><li><code>atom_count::Int64</code>: Number of elements (atoms) in the causet.</li><li><code>manifold::M</code>: The background manifold defining the causal structure.</li><li><code>branch_point_info::Tuple{Vector{Coordinates{N}}, Vector{Tuple{Coordinates{N}, Coordinates{N}}}}</code>:<ul><li>First element: Single branch points (each induces a timelike topological cut extending to the boundary).</li><li>Second element: Finite topological cuts (segments between two points).</li></ul></li><li><code>sprinkling::Vector{Coordinates{N}}</code>: Coordinates of the sprinkled points, typically sorted by time.</li></ul><p><strong>Purpose</strong></p><p>Encodes both the geometry and topology of the geometry underlying the causal set, allowing causal relations to be modified by finite or vertical topological obstructions. Used for modeling spacetimes with topology change or nontrivial causal structure.</p><p><strong>Notes</strong></p><ul><li>This type is interoperable with <code>CausalSets.in_past_of_unchecked</code>, <code>BitArrayCauset</code>, and related methods.</li><li>Vertical cuts (from single branch points) are interpreted as timelike obstructions to causal curves.</li><li>Finite cuts can be timelike, spacelike, or null and may intersect.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">import CausalSets
manifold = CausalSets.MinkowskiManifold{2}()
sprinkling = [CausalSets.Coordinates{2}((0.1, 0.0)), CausalSets.Coordinates{2}((0.9, 0.0))]
single_branch_points = [CausalSets.Coordinates{2}((0.5, 0.0))]
finite_cuts = [(CausalSets.Coordinates{2}((0.3, -1.0)), CausalSets.Coordinates{2}((0.3, 1.0)))]
causet = BranchedManifoldCauset(manifold, (single_branch_points, finite_cuts), sprinkling)</code></pre></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.make_branched_manifold_cset"><a class="docstring-binding" href="#QuantumGrav.make_branched_manifold_cset"><code>QuantumGrav.make_branched_manifold_cset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_branched_manifold_cset(
    npoints::Int64,
    n_vertical_cuts::Int64,
    n_finite_cuts::Int64,
    rng::AbstractRNG,
    order::Int64,
    r::Float64;
    d::Int64 = 2,
    tolerance::Float64 = 1e-12,
    type::Type{T} = Float32
) -&gt; Tuple{
    CausalSets.BitArrayCauset,
    Vector{Coordinates{2}},
    Tuple{Vector{Coordinates{2}}, Vector{Tuple{Coordinates{2}, Coordinates{2}}}},
    Matrix{T}
}</code></pre><p>Generate a branched causal set in a random polynomial manifold with timelike boundary-connecting and finite topological cuts.</p><p><strong>Purpose</strong></p><p>This function builds a toy model of a branched spacetime:</p><ol><li>A random 2D polynomial manifold is generated from Chebyshev coefficients with exponential decay.</li><li>A sprinkling of <code>npoints</code> events is placed into the manifold.</li><li>Random <strong>vertical cuts</strong> (from single branch points extending upward in time) and <strong>finite cuts</strong> (segments between two points) are introduced.</li><li>Points lying too close to cuts are filtered out.</li><li>A <a href="#QuantumGrav.BranchedManifoldCauset"><code>BranchedManifoldCauset</code></a> and its causal matrix (<code>BitArrayCauset</code>) are constructed.</li></ol><p><strong>Arguments</strong></p><ul><li><code>npoints::Int64</code>: Number of sprinkled points. Must be &gt; 0.</li><li><code>n_vertical_cuts::Int64</code>: Number of vertical cuts (≥ 0).</li><li><code>n_finite_cuts::Int64</code>: Number of finite cuts (≥ 0).</li><li><code>rng::AbstractRNG</code>: Random number generator.</li><li><code>order::Int64</code>: Order of the Chebyshev expansion (must be &gt; 0).</li><li><code>r::Float64</code>: Decay base for Chebyshev coefficients (must be &gt; 1).</li><li><code>d::Int64</code>: Dimension of the spacetime. Only <code>d = 2</code> is supported (default).</li><li><code>tolerance::Float64</code>: Minimal distance for filtering points too close to cuts and for computing spacetime distances (default: <code>1e-12</code>).</li><li><code>type::Type{T}</code>: Numeric type for the returned Chebyshev coefficient matrix (default: <code>Float32</code>).</li></ul><p><strong>Returns</strong></p><p>A 4-tuple <code>(cset, sprinkling, branch_point_info, chebyshev_coefs)</code>:</p><ul><li><code>cset::BitArrayCauset</code>: The causal set with branch cuts encoded.</li><li><code>sprinkling::Vector{Coordinates{2}}</code>: The filtered sprinkled points.</li><li><code>branch_point_info::Tuple{Vector{Coordinates{2}}, Vector{Tuple{Coordinates{2}, Coordinates{2}}}}</code>:<ul><li>Single branch points (for timelike boundary-connecting cuts),</li><li>Finite cut segments.</li></ul></li><li><code>chebyshev_coefs::Matrix{T}</code>: Chebyshev coefficients of the random polynomial manifold.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if any of:<ul><li><code>npoints ≤ 0</code></li><li><code>n_vertical_cuts &lt; 0</code></li><li><code>n_finite_cuts &lt; 0</code></li><li><code>order ≤ 0</code></li><li><code>r ≤ 1</code></li><li><code>d ≠ 2</code></li><li><code>tolerance ≤ 0</code></li></ul></li></ul><p><strong>Example</strong></p><p>```julia using Random, CausalSets rng = MersenneTwister(1234) cset, sprinkling, branch<em>info, coefs =     make</em>branched<em>manifold</em>cset(50, 2, 3, rng, 5, 2.0)</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h5 id="Merged-Causal-Sets"><a class="docs-heading-anchor" href="#Merged-Causal-Sets">Merged Causal Sets</a><a id="Merged-Causal-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Merged-Causal-Sets" title="Permalink"></a></h5><p>Merge and insert causal sets:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.merge_csets"><a class="docstring-binding" href="#QuantumGrav.merge_csets"><code>QuantumGrav.merge_csets</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>merge<em>csets(cset1Raw::AbstractCauset, cset2Raw::AbstractCauset, link</em>probability::Float64)      -&gt; BitArrayCauset</p><p>Merge two causal sets <code>cset1Raw</code> and <code>cset2Raw</code> into a single causal set by placing them on the diagonal of a larger causet and connecting them with random links in the upper-right block with probability <code>link_probability</code>. Transitive closure is applied after merging.</p><p>Note: The actual degree of connectivity is underestimated unless <code>link_probability</code> is 0 or 1, since transitive completion will overwrite the sparsity induced by random linking.</p><p><strong>Arguments</strong></p><ul><li><code>cset1Raw</code>: First input causal set (converted to <code>BitArrayCauset</code> if necessary)</li><li><code>cset2Raw</code>: Second input causal set (converted to <code>BitArrayCauset</code> if necessary)</li><li><code>link_probability</code>: Probability with which to add links from <code>cset1Raw</code> to <code>cset2Raw</code> (must be in [0, 1])</li></ul><p><strong>Returns</strong></p><ul><li>A <code>BitArrayCauset</code> representing the merged and transitively closed causal set</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>link_probability</code> is not in the interval [0, 1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.insert_cset"><a class="docstring-binding" href="#QuantumGrav.insert_cset"><code>QuantumGrav.insert_cset</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>insert<em>cset(cset1Raw::AbstractCauset, cset2Raw::AbstractCauset, link</em>probability::Float64; rng::AbstractRNG=Random.GLOBAL_RNG, position::Union{Nothing, Int64}=nothing)      -&gt; BitArrayCauset</p><p>Insert <code>cset2Raw</code> into <code>cset1Raw</code> at a random or specified position. All atoms are reindexed accordingly. Random links are added <em>across</em> the insertion boundary — i.e. from atoms before the inserted block to atoms inside it, and from the inserted block to atoms after it — with probability <code>link_probability</code>. Transitive closure is applied after insertion.</p><p><strong>Arguments</strong></p><ul><li><code>cset1Raw</code>: First input causal set (converted to <code>BitArrayCauset</code> if necessary)</li><li><code>cset2Raw</code>: Second input causal set (converted to <code>BitArrayCauset</code> if necessary)</li><li><code>link_probability</code>: Probability with which to add links across the insertion boundary (must be in [0, 1])</li><li><code>rng</code>: Random number generator (default: <code>Random.GLOBAL_RNG</code>)</li><li><code>position</code>: Optional insertion index in <code>0:n1</code>; if <code>nothing</code>, insertion is random</li></ul><p><strong>Returns</strong></p><ul><li>A <code>BitArrayCauset</code> representing the merged and transitively closed causal set</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>link_probability</code> is not in the interval [0, 1]</li><li><code>ArgumentError</code> if <code>position</code> is not in the valid range <code>0 ≤ position ≤ atom_count of cset1Raw</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.insert_KR_into_manifoldlike"><a class="docstring-binding" href="#QuantumGrav.insert_KR_into_manifoldlike"><code>QuantumGrav.insert_KR_into_manifoldlike</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>insert<em>KR</em>into<em>manifoldlike(npoints::Int64, order::Int64, r::Float64, link</em>probability::Float64;                              rng::AbstractRNG=Random.GLOBAL_RNG, position::Union{Nothing, Int64}=nothing,                             d::Int64=2, type::Type=Float32, p::Float64=0.5)     -&gt; Tuple{BitArrayCauset, Bool, Matrix{T}}</p><p>Generate a manifoldlike causal set and insert into it a KR-order (random layered) causal set. The insertion point is chosen randomly (or specified via <code>position</code>). Random links are added across the insertion boundary with probability <code>link_probability</code>. Transitive closure is applied to ensure consistency.</p><p>Returns the merged causet, a dummy <code>true</code>, and the coordinate matrix used for the manifoldlike causet.</p><p><strong>Arguments</strong></p><ul><li><code>npoints</code>: Total number of elements in the resulting causal set (may be off by 1 due to rounding errors)</li><li><code>order</code>: Sprinkling order for the manifoldlike causet</li><li><code>r</code>: Interaction scale for manifoldlike causet generation</li><li><code>link_probability</code>: Probability for adding links across the insertion boundary (must be in [0, 1])</li><li><code>rng</code>: Random number generator (default: <code>Random.GLOBAL_RNG</code>)</li><li><code>n2_rel</code>: Size of KR order relative to total size of resulting causet</li><li><code>position</code>: Optional insertion index in <code>0:npoints</code>; if <code>nothing</code>, insertion is random</li><li><code>d</code>: Dimension of the manifoldlike causal set (default: 2)</li><li><code>type</code>: Coordinate type (default: Float32)</li><li><code>p</code>: Link-probability within KR-order (default: 0.5)</li></ul><p><strong>Returns</strong></p><ul><li>A tuple <code>(cset, true, coords)</code> where:<ul><li><code>cset</code> is the merged and transitively completed <code>BitArrayCauset</code></li><li><code>true</code> is a placeholder flag</li><li><code>coords</code> is a <code>Matrix{T}</code> of coordinates used for the manifoldlike causet</li></ul></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>link_probability</code> is not in the interval [0, 1]</li><li><code>ArgumentError</code> if <code>position</code> is not in the valid range <code>0 ≤ position ≤ npoints</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h5 id="Destroyed-Causal-Sets"><a class="docs-heading-anchor" href="#Destroyed-Causal-Sets">Destroyed Causal Sets</a><a id="Destroyed-Causal-Sets-1"></a><a class="docs-heading-anchor-permalink" href="#Destroyed-Causal-Sets" title="Permalink"></a></h5><p>Destroy manifold-like structure through random edge flips:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.destroy_manifold_cset"><a class="docstring-binding" href="#QuantumGrav.destroy_manifold_cset"><code>QuantumGrav.destroy_manifold_cset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">destroy_manifold_cset(size::Int64, num_flips::Int64, rng::Random.AbstractRNG, order::Int64, r::Float64; d::Int64=2, type::Type{T}=Float32) -&gt; CausalSets.BitArrayCauset</code></pre><p>Starts from a manifold-like causal set and destroys its manifoldlike structure by flipping a given number of randomly chosen edges, then applies transitive closure.</p><p><strong>Arguments</strong></p><ul><li><code>size::Int64</code>: The number of elements in the causal set.</li><li><code>num_flips::Int64</code>: The number of edges to flip at random in the set (each flip toggles the presence/absence of a relation).</li><li><code>rng::Random.AbstractRNG</code>: Random number generator to use for reproducibility.</li><li><code>order::Int64</code>: The order parameter passed to the manifold causal set generator.</li><li><code>r::Float64</code>: The sprinkling density or radius parameter for the manifold causal set.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>d::Int64=2</code>: The dimension of the spacetime manifold to sprinkle into (default: 2).</li><li><code>type::Type{T}=Float32</code>: The numeric type for coordinates (default: Float32).</li></ul><p><strong>Returns</strong></p><ul><li><code>CausalSets.BitArrayCauset</code>: The resulting causal set as a BitArrayCauset, which may be non-manifoldlike after random edge flips.</li><li><code>sprinkling</code>: The sprinkling of the geometry underlying the destroyed causal set.</li><li><code>chebyshev_coefs</code>: The Chebyshev coefficients of the geometry underlying the destroyed causal set.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: if <code>num_flips &lt; 1</code>.</li><li><code>ArgumentError</code>: if <code>num_flips &gt; size*(size-1)/2</code>.</li></ul><p><strong>Behavior</strong></p><p>This function generates a manifold-like causal set using <code>make_polynomial_manifold_cset</code>, then randomly selects <code>num_flips</code> pairs of elements (edges) and flips their causal relation (adding or removing the edge). After all flips, it applies transitive closure to ensure the causality structure is consistent, and returns the final causal set as a <code>BitArrayCauset</code>.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h3 id="Curvature-Analysis"><a class="docs-heading-anchor" href="#Curvature-Analysis">Curvature Analysis</a><a id="Curvature-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Curvature-Analysis" title="Permalink"></a></h3><p>Compute curvature on manifold-like causal sets:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.Ricci_scalar_2D"><a class="docstring-binding" href="#QuantumGrav.Ricci_scalar_2D"><code>QuantumGrav.Ricci_scalar_2D</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Ricci_scalar_2D(
    coefs::Array{Float64, 2}, 
    position::CausalSets.Coordinates{2}; 
    derivation_matrix::Union{Nothing, Array{Float64, 2}}=nothing
) -&gt; Float64</code></pre><p>Computes the Ricci scalar curvature at a given position for a 2D Lorentzian manifold in conformally flat slicing with conformal factor expressed as Chebyshev expansion.</p><p><strong>Arguments</strong></p><ul><li><code>coefs::Array{Float64, 2}</code>: A matrix of Chebyshev coefficients representing the conformal factor expanded in two variables.</li><li><code>position::CausalSets.Coordinates{2}</code>: A 2D coordinate at which to evaluate the Ricci scalar.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>derivation_matrix1::Union{Nothing, Array{Float64, 2}}=nothing</code>: Optional precomputed Chebyshev derivation matrix for first derivatives to speed up computation.</li><li><code>derivation_matrix2::Union{Nothing, Array{Float64, 2}}=nothing</code>: Optional precomputed Chebyshev derivation matrix for second derivatives to speed up computation.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: The Ricci scalar curvature evaluated at the given position.</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError: if the coefficient matrix is not a square matrix. Asymmetric orders are not supported (but can be emulated by adding 0s in the coefficient matrix).</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.Ricci_scalar_2D_of_sprinkling"><a class="docstring-binding" href="#QuantumGrav.Ricci_scalar_2D_of_sprinkling"><code>QuantumGrav.Ricci_scalar_2D_of_sprinkling</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">Ricci_scalar_2D_of_sprinkling(
    coefs::Array{Float64, 2},
    sprinkling::Vector{CausalSets.Coordinates{2}};
    derivation_matrix1::Union{Nothing, Array{Float64, 2}}=nothing,
    derivation_matrix2::Union{Nothing, Array{Float64, 2}}=nothing,
) -&gt; Vector{Float64}</code></pre><p>Computes the Ricci scalar curvature at multiple points (sprinkling) for a 2D Lorentzian manifold in conformally flat slicing with conformal factor expressed as Chebyshev expansion.</p><p><strong>Arguments</strong></p><ul><li><code>coefs::Array{Float64, 2}</code>: A matrix of Chebyshev coefficients representing the conformal factor expanded in two variables.</li><li><code>sprinkling::Vector{CausalSets.Coordinates{2}}</code>: A vector of 2D coordinates at which to evaluate the Ricci scalar.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>derivation_matrix1::Union{Nothing, Array{Float64, 2}}=nothing</code>: Optional precomputed Chebyshev derivation matrix for first derivatives.</li><li><code>derivation_matrix2::Union{Nothing, Array{Float64, 2}}=nothing</code>: Optional precomputed Chebyshev derivation matrix for second derivatives.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float64}</code>: A vector of Ricci scalar curvature values evaluated at the given points.</li></ul><p><strong>Throws</strong></p><ul><li>ArgumentError: if the coefficient matrix is not a square matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h3 id="Causal-Set-Factories"><a class="docs-heading-anchor" href="#Causal-Set-Factories">Causal Set Factories</a><a id="Causal-Set-Factories-1"></a><a class="docs-heading-anchor-permalink" href="#Causal-Set-Factories" title="Permalink"></a></h3><p>Factory pattern for generating different types of causal sets:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.PolynomialCsetMaker"><a class="docstring-binding" href="#QuantumGrav.PolynomialCsetMaker"><code>QuantumGrav.PolynomialCsetMaker</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolynomialCsetMaker

Causal set maker for a polynomial manifold.</code></pre><p><strong>Fields:</strong></p><ul><li><code>order_distribution::Distributions.Distribution</code>: distribution of polynomial orders</li><li><code>r_distribution::Distributions.Distribution</code>: distribution of exponential decay exponents</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.RandomCsetMaker"><a class="docstring-binding" href="#QuantumGrav.RandomCsetMaker"><code>QuantumGrav.RandomCsetMaker</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RandomCsetMaker

Causal set maker for a random causal set.</code></pre><p><strong>Fields:</strong></p><ul><li><code>cdistr::Distributions.Distribution</code>: distribution of connectivity goals</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.LayeredCsetMaker"><a class="docstring-binding" href="#QuantumGrav.LayeredCsetMaker"><code>QuantumGrav.LayeredCsetMaker</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LayeredCsetMaker

Causal set maker for a layered causal set.</code></pre><p><strong>Fields:</strong></p><ul><li><code>connectivity_distribution::Distributions.Distribution</code>: distribution of connectivity goals</li><li><code>stddev_distribution::Distributions.Distribution</code>: distribution of standard deviations</li><li><code>layer_distribution::Distributions.Distribution</code>: distribution of layer counts</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.DestroyedCsetMaker"><a class="docstring-binding" href="#QuantumGrav.DestroyedCsetMaker"><code>QuantumGrav.DestroyedCsetMaker</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DestroyedCsetMaker

Causal set maker for a destroyed causal set, which has a set of edges flipped in a polynomial causal set.</code></pre><p><strong>Fields:</strong></p><ul><li><code>order_distribution::Distributions.Distribution</code>: distribution of order values</li><li><code>r_distribution::Distributions.Distribution</code>: distribution of r values</li><li><code>flip_distribution::Distributions.Distribution</code>: distribution of flip values</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.GridCsetMakerPolynomial"><a class="docstring-binding" href="#QuantumGrav.GridCsetMakerPolynomial"><code>QuantumGrav.GridCsetMakerPolynomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GridCsetMakerPolynomial

Create a new `grid` causal set maker object from the config dictionary for polynomial spacetimes.</code></pre><p><strong>Fields:</strong></p><pre><code class="language-julia hljs">- grid_distribution::Distributions.Distribution: Random distribution to draw grid from
- rotate_distribution::Distributions.Distribution: Random distribution to draw rotation angle from
- order_distribution::Distributions.Distribution: Random distribution to draw order from
- r_distribution::Distributions.Distribution: Random distribution to draw exponent for Chebyshev expansionfrom
- grid_lookup::AbstractDict: grid lookup table by name</code></pre></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.MergedCsetMaker"><a class="docstring-binding" href="#QuantumGrav.MergedCsetMaker"><code>QuantumGrav.MergedCsetMaker</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MergedCsetMaker

Causal set maker from a given configuration dictionary.</code></pre><p><strong>Fields:</strong></p><ul><li><code>link_prob_distribution::Distributions.Distribution</code>: distribution of link probabilities</li><li><code>order_distribution::Distributions.Distribution</code>: distribution of order values</li><li><code>r_distribution::Distributions.Distribution</code>: distribution of r values</li><li><code>n2_rel_distribution::Distributions.Distribution</code>: distribution of n2 relative values</li><li><code>connectivity_distribution::Distributions.Distribution</code>: distribution of connectivity values</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.ComplexTopCsetMaker"><a class="docstring-binding" href="#QuantumGrav.ComplexTopCsetMaker"><code>QuantumGrav.ComplexTopCsetMaker</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ComplexTopCsetMaker</code></pre><p>A callable struct to produce complex topology csets with various causality-cutting &#39;lines&#39; in a 2D manifold</p><p><strong>Fields:</strong></p><ul><li><code>vertical_cut_distr::Distributions.Distribution</code>: Distribution to draw the number of vertical (time direction) cuts from</li><li><code>finite_cut_distr::Distributions.Distribution</code>: Distribution to draw the number of mixed direction cuts from</li><li><code>order_distribution::Distributions.Distribution</code>: Distribution to draw the number of orders for the polynomial expansion from</li><li><code>r_distribution::Distributions.Distribution</code>: Distribution to draw the decay exponent for the orders in the polynomial expansion from</li><li><code>tol::Float64</code>: Floating point comparison tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.CsetFactory"><a class="docstring-binding" href="#QuantumGrav.CsetFactory"><code>QuantumGrav.CsetFactory</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CsetFactory</code></pre><p>The <code>CsetFactory</code> struct serves as a container for generating causal sets (csets). It holds the configuration, random number generator, and distribution information required to create csets, and provides access to specialized factory functions for different cset types.</p><p><strong>Fields:</strong></p><ul><li><code>npoint_distribution::Distributions.Distribution</code>: Distribution object for drawing number of elements in a cset</li><li><code>conf::AbstractDict</code>: config dictionary</li><li><code>rng::Random.AbstractRNG</code>: random number generator to use</li><li><code>cset_makers::AbstractDict</code>: dict to hold all the different cset factory methods</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.encode_csettype"><a class="docstring-binding" href="#QuantumGrav.encode_csettype"><code>QuantumGrav.encode_csettype</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">encode_csettype(config)</code></pre><p>Encode known cset types into numeric scheme.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h3 id="Data-Storage-and-Preparation"><a class="docs-heading-anchor" href="#Data-Storage-and-Preparation">Data Storage and Preparation</a><a id="Data-Storage-and-Preparation-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Storage-and-Preparation" title="Permalink"></a></h3><p>Tools for data production and storage:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.prepare_dataproduction"><a class="docstring-binding" href="#QuantumGrav.prepare_dataproduction"><code>QuantumGrav.prepare_dataproduction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">prepare_dataproduction(config::AbstractDict, funcs_to_copy::Vector{Any})::Tuple{str, Zarr.DirectoryStore}</code></pre><p>Prepare the data production process from the config dict supplied.</p><ul><li>create a target directory</li><li>copy over the source files of the passed functions. The user has to select these based on their importance for data production and whether they should be retained together with the data in the target directory</li><li>store the git info of the QuantumGrav package (branch, tree hash, source) used</li><li>save the config file, augmented with git info,  to the target directory</li><li>create a zarr directorystore based on the config file.</li></ul><p><strong>Arguments</strong></p><p>config::AbstractDict Config file defining the data generation system funcs<em>to</em>copy::Vector{Any} Functions which are to be used and whose source files are to be copied to be retained</p><p><strong>Keyword arguments</strong></p><p>name::String Prefix for the created zarr file. Will be followed by the caller process pid and the date in yyyy-mm-dd_HH-MM-SS</p><p><strong>Returns</strong></p><p>Tuple{String, Zarr.DirectoryStore} The path to the output file and the output file itself.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.copy_sourcecode"><a class="docstring-binding" href="#QuantumGrav.copy_sourcecode"><code>QuantumGrav.copy_sourcecode</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">copy_sourcecode(funcs_to_copy::Vector{Any}, targetpath::String)</code></pre><p>Copy the sourcecode files of the functions in the arguments to a targetpath.</p><p><strong>Arguments:</strong></p><p>funcs<em>to</em>copy::Vector list of functions to copy the sourcecode files of targetpath::String local path to copy the files to</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.get_git_info!"><a class="docstring-binding" href="#QuantumGrav.get_git_info!"><code>QuantumGrav.get_git_info!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_git_info!(config::AbstractDict)</code></pre><p>Get git info (branch, source, tree_hash) of the QuantumGrav package</p><p><strong>Arguments</strong></p><p>config::AbstractDict Config dictionary to put the git data into</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.dict_to_zarr"><a class="docstring-binding" href="#QuantumGrav.dict_to_zarr"><code>QuantumGrav.dict_to_zarr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dict_to_zarr(file_or_group::Union{Zarr.DirectoryStore, Zarr.ZGroup}, data::Dict{Any, Any}, compressor_kwargs = Dict(:clevel =&gt; 9, :cname =&gt; &quot;lz4&quot;, :shuffle =&gt; 2), chunking_strategy::Union{Dict{String, Function}, Function, Nothing} = default_chunks)</code></pre><p>Recursively write a nested dictionary to a Zarr group.</p><p><strong>Arguments:</strong></p><ul><li><code>file_or_group</code>: Zarr DirectoryStore or Group to write the data to</li><li><code>data</code>: Nested dictionary to write</li><li><code>compressor_kwargs</code>: Compression options for the arrays</li><li><code>chunking_strategy</code>: Chunking strategy for the arrays. If you want not chunking, use &#39;nothing&#39; here.</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h3 id="Graph-Utilities"><a class="docs-heading-anchor" href="#Graph-Utilities">Graph Utilities</a><a id="Graph-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-Utilities" title="Permalink"></a></h3><p>Low-level graph operations:</p><article><details class="docstring" open="true"><summary id="QuantumGrav.make_adj"><a class="docstring-binding" href="#QuantumGrav.make_adj"><code>QuantumGrav.make_adj</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> make_adj(c::CausalSets.AbstractCauset; type::Type{M} = SparseArrays.SparseMatrixCSC, eltype::Type{T} = Float32)::AbstractMatrix{T} where {T&lt;:Number,M&lt;:AbstractArray}</code></pre><p>Creates an adjacency matrix from a causet&#39;s future relations.</p><p><strong>Arguments</strong></p><ul><li><code>c::CausalSets.AbstractCauset</code>: The causet object containing future relations</li><li><code>type::Type{M}</code>: Array type for the adjacency matrix entries. Must be a subtype of AbstractArray</li><li><code>eltype::Type{T}</code>: Numeric element type to store the elements. Ignored if you pass in a BitMatrix, which has no element type.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractMatrix{T}</code>: Adjacency matrix of the specified matrix type (as given by the <code>type</code> parameter), constrained to subtypes of <code>AbstractMatrix</code>.</li></ul><p><strong>Notes</strong></p><p>Converts the causet&#39;s future_relations to a matrix format by horizontally concatenating, transposing, and converting to the specified type.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.max_pathlen"><a class="docstring-binding" href="#QuantumGrav.max_pathlen"><code>QuantumGrav.max_pathlen</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">maxpathlen(adj_matrix::AbstractMatrix, topo_order::AbstractVector, source::Int) -&gt; Int32</code></pre><p>Calculates the maximum path length from a source node in a directed acyclic graph.</p><p><strong>Arguments</strong></p><ul><li><code>adj_matrix::AbstractMatrix</code>: Adjacency matrix representing the directed graph</li><li><code>topo_order::AbstractVector{Int}</code>: Topologically sorted order of vertices</li><li><code>source::Int</code>: Source vertex index to calculate distances from</li></ul><p><strong>Returns</strong></p><ul><li><code>Int32</code>: Maximum finite distance from the source node, or 0 if no paths exist</li></ul><p><strong>Notes</strong></p><p>Uses dynamic programming with topological ordering for efficient longest path computation. Processes vertices in topological order to ensure optimal substructure property. Returns 0 if no finite distances exist from the source.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.transitive_reduction!"><a class="docstring-binding" href="#QuantumGrav.transitive_reduction!"><code>QuantumGrav.transitive_reduction!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">transitive_reduction!(mat::AbstractMatrix)</code></pre><p>Compute the transitive reduction of the input matrix, such that only connections (i,j) remain that have a max pathlen of 1. This assumes that the input matrix is upper triangular, i.e., a topologically ordered DAG. If that is not the case, the results will be incorrect.</p><p><strong>Arguments</strong></p><ul><li><code>mat::AbstractMatrix</code>: The input matrix to compute the transitive reduction on</li></ul></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><h3 id="Helper-Functions"><a class="docs-heading-anchor" href="#Helper-Functions">Helper Functions</a><a id="Helper-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="QuantumGrav.make_pseudosprinkling"><a class="docstring-binding" href="#QuantumGrav.make_pseudosprinkling"><code>QuantumGrav.make_pseudosprinkling</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">make_pseudosprinkling(n, d, box_min, box_max, type; rng) -&gt; Vector{Vector{T}}</code></pre><p>Generates random points uniformly distributed in a d-dimensional box.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int64</code>: Number of points to generate</li><li><code>d::Int64</code>: Dimension of each point</li><li><code>box_min::Float64</code>: Minimum coordinate value</li><li><code>box_max::Float64</code>: Maximum coordinate value</li><li><code>type::Type{T}</code>: Numeric type for coordinates</li><li><code>rng</code>: Random number generator (default: Xoshiro(1234))</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{T}}</code>: Vector of n points, each point is a d-dimensional vector</li></ul><p><strong>Notes</strong></p><p>Used for creating pseudo-sprinklings in PseudoManifold when geometric manifold sprinkling is not applicable.</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantumGrav.validate_config"><a class="docstring-binding" href="#QuantumGrav.validate_config"><code>QuantumGrav.validate_config</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs"> validate_config(schema, cfg)::Nothing</code></pre><p>Validate a config using a json schema it must adhere to</p><p><strong>Arguments</strong></p><ul><li>schema: json schema to test against</li><li>config: config dictionary to test</li></ul><p><strong>Returns</strong></p><ul><li>nothing</li></ul><p><strong>throws</strong></p><p>Argument error: if validation fails</p></div><a class="docs-sourcelink" target="_blank" href="ssciwr/QuantumGrav">source</a></section></details></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 7 December 2025 20:00">Sunday 7 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
