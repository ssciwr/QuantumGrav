var documenterSearchIndex = {"docs":
[{"location":"#QuantumGrav.jl","page":"QuantumGrav.jl","title":"QuantumGrav.jl","text":"","category":"section"},{"location":"#Getting-Started","page":"QuantumGrav.jl","title":"Getting Started","text":"This package provides functionality to generate csets of different types. Currently, it only supports 2D causal sets in general. The package builds on CausalSets.jl.\n\nCurrently supported are:\n\nsimply connected manifold like causal sets based on analytical manifolds\nmanifold like csets with complex, branched connections\nrandom: Causal sets with randomly selected links\nlayered: Causal sets in which events are ordered in layers along the time dimension.\nmerged: A merger of a random and manifold like causal set\ndestroyed: A manifold like causal set with some edges being flipped, which makes it a non-manifold like causal set.\ngrid like: Causal sets in which events are ordered in a grid like fashion according to a certain scheme, which can be one of 'quadratic', 'rectangular', 'rhombic', 'hexagonal', 'oblique'\n\nYou currently have to install the package from the github repository directly:\n\nimport Pkg\nPkg.add(url = \"https://github.com/ssciwr/QuantumGrav.git\", subdir=\"QuantumGrav.jl\")","category":"section"},{"location":"#Usage","page":"QuantumGrav.jl","title":"Usage","text":"The main entry point for cset generation is the CsetFactory struct. This is constructed from a configuration dictionary that can be read from disk. The configuration can be stored in any kind of file that results in a nested dictionary as described below, but YAML is the most common and typically prefered format.\n\nimport QuantumGrav as QG\nimport YAML\nconfig = _YAML.load_file(joinpath(\"path\", \"to\", \"configfile.yaml\")) # load from yaml file.\ncsetfactory = QG.CsetFactory(config)\n\nOnce an instance of this struct is created, you can construct a new cset via:\n\ncset = csetfactory((\n    \"random\", # a cset type as described above\n    1000, # number of events in the cset\n))\n\nThis will return a causal set of the requested size and kind of the type CausalSets.BitArrayCauset.\n\nThis package uses the zarr format for storing data to file. From a constructed cset, a multitude of observables can be derived. These can be stored in a dictionary that then can be written directly into a zarr file. Secondly, a helper function is provided to copy the config and the source code used to generate the observables to the same directory as the data and creates a Zarr DirectoryStore there. This helps with reproducibility and documentation of different data generation runs. The created Zarr file will contain the pid of the generating process and the date and time in yyyy-mm-dd_HH-MM-SS format.\n\nWe first define a function that takes a Causal Set factory and builds a dictionary of computed observables:\n\nimport QuantumGrav as QG\nimport Random\nimport Zarr\n\nfunction make_cset_data(csetfactory)\n    cset = csetfactory(\n        \"random\", # a cset type as described above\n        1000, # number of events in the cset\n    )\n\n    return Dict(\n        \"observable1\" => make_observable1(cset) # assume the `make_observable1` would be user defined\n        \"observable2\" => make_observable2(cset)\n    )\nend\n\nThen we load the config and call the prepare_dataproduction function to set everything up. The second argument will serve as an anchor to determine which source code files shall be copied over. In this case, it will be the file where the make_cset_data function is defined. If you add other functions, their respective sourcecode files will be copied as well.\n\nconfig = _YAML.load_file(joinpath(\"path\", \"to\", \"configfile.yaml\")) # load from yaml file.\n\npath_to_store, zarr_store = QG.prepare_dataproduction(\n    config,\n    [make_cset_data];\n    nameaddition = \"random_data\", # will create a folder starting with 'random_data' and ending with '.zarr'\n)\n\n# make the factory\nfactory = QG.CsetFactory(config)\n\nFinally, we create our data. This can also be parallelized with Threads.@threads, Distributed.@distributed, Distributed.pmap or in other ways.\n\nfor i in 1:num_csets\n    data = Dict(\"cset_$i\"=> make_cset_data(factory))\n    QG.dict_to_zarr(file, data)\nend\n\nThe whole procedure will result in a directory output/random_data_{pid}_{yyyy-mm-dd_HH-MM-SS}.zarr, which contains directories cset_{i} and therein the respective observables.\n\nThe resulting directory structure will look like this:\n\noutput/\n└── random_data_12345_2025-11-13_14-30-45.zarr/\n    ├── .zattrs                    # Zarr metadata\n    ├── .zgroup                    # Zarr group marker\n    ├── config.yaml                # Copy of configuration used\n    ├── make_cset_data.jl          # Source code snapshot\n    ├── ...                        # other sourcecode files\n    ├── cset_1/\n    │   ├── .zgroup\n    │   ├── observable1/           # Arrays stored as Zarr arrays\n    │   │   ├── .zarray\n    │   │   └── ...\n    │   └── observable2/\n    │       ├── .zarray\n    │       └── ...\n    ├── cset_2/\n    │   ├── .zgroup\n    │   ├── observable1/\n    │   └── observable2/\n    │\n    ├── ...                        # more csets\n    └── cset_N/\n        ├── .zgroup\n        ├── observable1/\n        └── observable2/","category":"section"},{"location":"#Configuration","page":"QuantumGrav.jl","title":"Configuration","text":"The causal set factories each come with a specific configuration dictionary that is validated by JSON schemas. Each cset type requires specific distribution parameters that control the stochastic generation process.","category":"section"},{"location":"#Top-Level-Configuration","page":"QuantumGrav.jl","title":"Top-Level Configuration","text":"The main CsetFactory configuration requires:\n\nseed (integer): Random seed for reproducibility\nnum_datapoints (integer, ≥0): Number of data points to generate\ncsetsize_distr (string): Name of distribution for causet sizes (e.g., \"DiscreteUniform\")\ncsetsize_distr_args (array of integers): Arguments for the size distribution\ncsetsize_distr_kwargs (object, optional): Keyword arguments for the size distribution\ncset_type (string or array of strings): Type(s) of causets to generate (see below)\noutput (string): Output file path\n\nPlus nested configurations for each cset type (see below).","category":"section"},{"location":"#Polynomial-Manifold-Configuration-(polynomial)","page":"QuantumGrav.jl","title":"Polynomial Manifold Configuration (polynomial)","text":"Required fields:\n\norder_distribution (string): Distribution name for polynomial order (must yield integers)\norder_distribution_args (array of integers): Distribution arguments\norder_distribution_kwargs (object, optional): Distribution keyword arguments\nr_distribution (string): Distribution name for exponential decay parameter\nr_distribution_args (array of numbers): Distribution arguments (must be > 1)\nr_distribution_kwargs (object, optional): Distribution keyword arguments\n\nExample:\n\nconfig[\"polynomial\"] = Dict(\n    \"order_distribution\" => \"DiscreteUniform\",\n    \"order_distribution_args\" => [3, 10],\n    \"order_distribution_kwargs\" => Dict(),\n    \"r_distribution\" => \"Uniform\",\n    \"r_distribution_args\" => [1.5, 3.0],\n    \"r_distribution_kwargs\" => Dict()\n)","category":"section"},{"location":"#Layered-Configuration-(layered)","page":"QuantumGrav.jl","title":"Layered Configuration (layered)","text":"Required fields:\n\nconnectivity_distribution (string): Distribution for connectivity probability between layers\nconnectivity_distribution_args (array of numbers): Distribution arguments (should be in [0,1])\nconnectivity_distribution_kwargs (object, optional): Distribution keyword arguments\nstddev_distribution (string): Distribution for Gaussian standard deviation in layer sizes\nstddev_distribution_args (array of numbers): Distribution arguments\nstddev_distribution_kwargs (object, optional): Distribution keyword arguments\nlayer_distribution (string): Distribution for number of layers\nlayer_distribution_args (array of integers): Distribution arguments\nlayer_distribution_kwargs (object, optional): Distribution keyword arguments\n\nExample:\n\nconfig[\"layered\"] = Dict(\n    \"connectivity_distribution\" => \"Uniform\",\n    \"connectivity_distribution_args\" => [0.3, 0.7],\n    \"connectivity_distribution_kwargs\" => Dict(),\n    \"stddev_distribution\" => \"Uniform\",\n    \"stddev_distribution_args\" => [5.0, 20.0],\n    \"stddev_distribution_kwargs\" => Dict(),\n    \"layer_distribution\" => \"DiscreteUniform\",\n    \"layer_distribution_args\" => [3, 10],\n    \"layer_distribution_kwargs\" => Dict()\n)","category":"section"},{"location":"#Random-(Connectivity-Based)-Configuration-(random)","page":"QuantumGrav.jl","title":"Random (Connectivity-Based) Configuration (random)","text":"Required fields:\n\nconnectivity_distribution (string): Distribution for target connectivity ratio\nconnectivity_distribution_args (array of numbers): Distribution arguments (should be in (0,1])\nconnectivity_distribution_kwargs (object, optional): Distribution keyword arguments\nmax_iter (integer, ≥1): Maximum MCMC iterations per attempt\nnum_tries (integer, ≥1): Number of attempts before giving up\nabs_tol (number or null): Absolute tolerance for convergence (use null if using rel_tol)\nrel_tol (number or null): Relative tolerance for convergence (use null if using abs_tol)\n\nNote: Exactly one of abs_tol or rel_tol should be non-null.\n\nExample:\n\nconfig[\"random\"] = Dict(\n    \"connectivity_distribution\" => \"Uniform\",\n    \"connectivity_distribution_args\" => [0.1, 0.9],\n    \"connectivity_distribution_kwargs\" => Dict(),\n    \"max_iter\" => 10000,\n    \"num_tries\" => 3,\n    \"abs_tol\" => 0.01,\n    \"rel_tol\" => nothing\n)","category":"section"},{"location":"#Destroyed-Configuration-(destroyed)","page":"QuantumGrav.jl","title":"Destroyed Configuration (destroyed)","text":"Required fields:\n\norder_distribution (string): Distribution for polynomial order (integers)\norder_distribution_args (array of integers): Distribution arguments\norder_distribution_kwargs (object, optional): Distribution keyword arguments\nr_distribution (string): Distribution for exponential decay parameter\nr_distribution_args (array of numbers): Distribution arguments\nr_distribution_kwargs (object, optional): Distribution keyword arguments\nflip_distribution (string): Distribution for fraction of edges to flip\nflip_distribution_args (array of numbers): Distribution arguments (typically in [0,1])\nflip_distribution_kwargs (object, optional): Distribution keyword arguments\n\nExample:\n\nconfig[\"destroyed\"] = Dict(\n    \"order_distribution\" => \"DiscreteUniform\",\n    \"order_distribution_args\" => [3, 8],\n    \"order_distribution_kwargs\" => Dict(),\n    \"r_distribution\" => \"Uniform\",\n    \"r_distribution_args\" => [1.5, 2.5],\n    \"r_distribution_kwargs\" => Dict(),\n    \"flip_distribution\" => \"Uniform\",\n    \"flip_distribution_args\" => [0.05, 0.3],\n    \"flip_distribution_kwargs\" => Dict()\n)","category":"section"},{"location":"#Grid-Configuration-(grid)","page":"QuantumGrav.jl","title":"Grid Configuration (grid)","text":"Required fields (similar to polynomial, plus grid-specific):\n\ngrid_distribution (string): Distribution for grid type index\ngrid_distribution_args (array of integers): Distribution arguments\ngrid_distribution_kwargs (object, optional): Distribution keyword arguments\nrotate_distribution (string): Distribution for rotation angle (degrees)\nrotate_distribution_args (array of numbers): Distribution arguments\nrotate_distribution_kwargs (object, optional): Distribution keyword arguments\norder_distribution, r_distribution: Same as polynomial configuration\n\nGrid types: 'quadratic', 'rectangular', 'rhombic', 'hexagonal', 'oblique'. Each grid type has their own parameters.\n\nExample\n\nconfig[\"grid\"] = Dict(\n        \"grid_distribution\" => \"DiscreteUniform\",\n        \"grid_distribution_args\" => [1, 6],\n        \"grid_distribution_kwargs\" => Dict(),\n        \"rotate_distribution\" => \"Uniform\",\n        \"rotate_distribution_args\" => [0.0, 180.0],\n        \"rotate_distribution_kwargs\" => Dict(),\n        \"order_distribution\" => \"DiscreteUniform\",\n        \"order_distribution_args\" => [2, 8],\n        \"order_distribution_kwargs\" => Dict(),\n        \"r_distribution\" => \"Uniform\",\n        \"r_distribution_args\" => [4.0, 8.0],\n        \"r_distribution_kwargs\" => Dict(),\n        \"quadratic\" => Dict(), # nothing needed here\n        \"rectangular\" => Dict(\n            \"segment_ratio_distribution\" => \"Beta\",\n            \"segment_ratio_distribution_args\" => [2.0, 1.2],\n            \"segment_ratio_distribution_kwargs\" => Dict(),\n        ),\n        \"rhombic\" => Dict(\n            \"segment_ratio_distribution\" => \"Uniform\",\n            \"segment_ratio_distribution_args\" => [0.5, 5.5],\n            \"segment_ratio_distribution_kwargs\" => Dict(),\n        ),\n        \"hexagonal\" => Dict(\n            \"segment_ratio_distribution\" => \"Normal\",\n            \"segment_ratio_distribution_args\" => [2.0, 0.5],\n            \"segment_ratio_distribution_kwargs\" => Dict(),\n        ),\n        \"triangular\" => Dict(\n            \"segment_ratio_distribution\" => \"Normal\",\n            \"segment_ratio_distribution_args\" => [3.3, 1.2],\n            \"segment_ratio_distribution_kwargs\" => Dict(),\n        ),\n        \"oblique\" => Dict(\n            \"segment_ratio_distribution\" => \"Logistic\",\n            \"segment_ratio_distribution_args\" => [2.0, 1.0],\n            \"segment_ratio_distribution_kwargs\" => Dict(),\n            \"oblique_angle_distribution\" => \"Normal\",\n            \"oblique_angle_distribution_args\" => [45.0, 15.0],\n            \"oblique_angle_distribution_kwargs\" => Dict(),\n        ),\n    )","category":"section"},{"location":"#Merged-Configuration-(merged)","page":"QuantumGrav.jl","title":"Merged Configuration (merged)","text":"Required fields:\n\norder_distribution, r_distribution: For the manifold component\nlink_prob_distribution (string): Distribution for cross-insertion link probability\nlink_prob_distribution_args (array of numbers): Distribution arguments (in [0,1])\nlink_prob_distribution_kwargs (object, optional): Distribution keyword arguments\nn2_rel_distribution (string): Distribution for relative size of inserted component\nn2_rel_distribution_args (array of numbers): Distribution arguments\nn2_rel_distribution_kwargs (object, optional): Distribution keyword arguments\nconnectivity_distribution (string): Distribution for connectivity of inserted random component\nconnectivity_distribution_args (array of numbers): Distribution arguments\nconnectivity_distribution_kwargs (object, optional): Distribution keyword arguments\n\nExample\n\nconfig[\"merged\"] = Dict(\n            \"order_distribution\" => \"DiscreteUniform\",\n            \"order_distribution_args\" => [2, 8],\n            \"order_distribution_kwargs\" => Dict(),\n            \"r_distribution\" => \"Normal\",\n            \"r_distribution_args\" => [4.0, 2.0],\n            \"r_distribution_kwargs\" => Dict(),\n            \"n2_rel_distribution\" => \"Uniform\",\n            \"n2_rel_distribution_args\" => [0., 1.0],\n            \"n2_rel_distribution_kwargs\" => Dict(),\n            \"connectivity_distribution\" => \"Beta\",\n            \"connectivity_distribution_args\" => [0.5, 0.1],\n            \"connectivity_distribution_kwargs\" => Dict(),\n            \"link_prob_distribution\" => \"Normal\",\n            \"link_prob_distribution_args\" => [2.0, 1.5],\n            \"link_prob_distribution_kwargs\" => Dict(),\n)","category":"section"},{"location":"#Complex-Topology-Configuration-(complex_topology)","page":"QuantumGrav.jl","title":"Complex Topology Configuration (complex_topology)","text":"Required fields:\n\norder_distribution, r_distribution: For the base manifold\nvertical_cut_distribution (string): Distribution for number of vertical (timelike) cuts\nvertical_cut_distribution_args (array of numbers): Distribution arguments\nvertical_cut_distribution_kwargs (object, optional): Distribution keyword arguments\nfinite_cut_distribution (string): Distribution for number of finite (mixed) cuts\nfinite_cut_distribution_args (array of numbers): Distribution arguments\nfinite_cut_distribution_kwargs (object, optional): Distribution keyword arguments\ntol (number): Floating point tolerance for geometric comparisons\n\nExample:\n\nconfig[\"complex_topology\"] = Dict(\n    \"order_distribution\" => \"DiscreteUniform\",\n    \"order_distribution_args\" => [3, 8],\n    \"order_distribution_kwargs\" => Dict(),\n    \"r_distribution\" => \"Uniform\",\n    \"r_distribution_args\" => [1.5, 2.5],\n    \"r_distribution_kwargs\" => Dict(),\n    \"vertical_cut_distribution\" => \"DiscreteUniform\",\n    \"vertical_cut_distribution_args\" => [0, 3],\n    \"vertical_cut_distribution_kwargs\" => Dict(),\n    \"finite_cut_distribution\" => \"DiscreteUniform\",\n    \"finite_cut_distribution_args\" => [0, 2],\n    \"finite_cut_distribution_kwargs\" => Dict(),\n    \"tol\" => 1e-12\n)","category":"section"},{"location":"#Distribution-Specification","page":"QuantumGrav.jl","title":"Distribution Specification","text":"All distributions use the pattern:\n\n<name>_distribution: String name of a univariate distribution from Distributions.jl (e.g., \"Uniform\", \"Normal\", \"DiscreteUniform\")\n<name>_distribution_args: Positional arguments as array (e.g., [min, max] for Uniform)\n<name>_distribution_kwargs: Optional keyword arguments as dictionary. Usually not needed.\n\nCommon distributions:\n\nUniform(a, b): Continuous uniform on [a, b]\nNormal(μ, σ): Normal with mean μ and std σ\nDiscreteUniform(a, b): Discrete uniform on {a, a+1, ..., b}\n\nSee the documentation of Distributions.jl for all available distributions and their needed parameters","category":"section"},{"location":"#API","page":"QuantumGrav.jl","title":"API","text":"A Julia package for generating and manipulating causal sets for quantum gravity research.","category":"section"},{"location":"#Causal-Set-Generation","page":"QuantumGrav.jl","title":"Causal Set Generation","text":"","category":"section"},{"location":"#Manifold-like-Causal-Sets","page":"QuantumGrav.jl","title":"Manifold-like Causal Sets","text":"Generate causal sets by sprinkling points into polynomial manifolds:","category":"section"},{"location":"#Layered-Causal-Sets","page":"QuantumGrav.jl","title":"Layered Causal Sets","text":"Generate layered causal sets with controlled connectivity between layers:","category":"section"},{"location":"#Connectivity-Based-Sampling","page":"QuantumGrav.jl","title":"Connectivity-Based Sampling","text":"Sample causal sets targeting specific connectivity values:","category":"section"},{"location":"#Grid-like-Causal-Sets","page":"QuantumGrav.jl","title":"Grid-like Causal Sets","text":"Generate regular grid structures in causal sets:","category":"section"},{"location":"#Branched-Manifold-Causal-Sets","page":"QuantumGrav.jl","title":"Branched Manifold Causal Sets","text":"Generate causal sets with complex topological features:","category":"section"},{"location":"#Merged-Causal-Sets","page":"QuantumGrav.jl","title":"Merged Causal Sets","text":"Merge and insert causal sets:","category":"section"},{"location":"#Destroyed-Causal-Sets","page":"QuantumGrav.jl","title":"Destroyed Causal Sets","text":"Destroy manifold-like structure through random edge flips:","category":"section"},{"location":"#Curvature-Analysis","page":"QuantumGrav.jl","title":"Curvature Analysis","text":"Compute curvature on manifold-like causal sets:","category":"section"},{"location":"#Causal-Set-Factories","page":"QuantumGrav.jl","title":"Causal Set Factories","text":"Factory pattern for generating different types of causal sets:","category":"section"},{"location":"#Data-Storage-and-Preparation","page":"QuantumGrav.jl","title":"Data Storage and Preparation","text":"Tools for data production and storage:","category":"section"},{"location":"#Graph-Utilities","page":"QuantumGrav.jl","title":"Graph Utilities","text":"Low-level graph operations:","category":"section"},{"location":"#Helper-Functions","page":"QuantumGrav.jl","title":"Helper Functions","text":"","category":"section"},{"location":"#QuantumGrav.make_polynomial_manifold_cset","page":"QuantumGrav.jl","title":"QuantumGrav.make_polynomial_manifold_cset","text":"make_polynomial_manifold_cset(npoints::Int64, rng::Random.AbstractRNG, order::Int64, r::Float64, d::Int64=2, type::Type{T}=Float32)::Tuple{CausalSets.BitArrayCauset,Vector{Tuple{T, Vargarg{T}}},Matrix{T}} where {T<:Number}\n\nGenerate a causal set by sampling from a positive polynomial constructed via a truncated  Chebyshev series with exponentially decaying coefficients.\n\nArguments\n\nnpoints::Int: Number of elements to sprinkle into the causal set. Must be > 0.\nseed::Int: Seed for pseudo-random number generation to ensure reproducibility.\norder::Int: Truncation order of the Chebyshev expansion (number of basis functions in each direction). Must be > 0.\nr::Float64: Decay base for Chebyshev coefficients. Must be > 1 to ensure exponential convergence; defines the radius of analyticity in the complex plane.\n\nKeyword arguments\n\nd::Int64: Dimension of the manifold, defaults to 2. Currently, only 2D is supported.\ntype::Type{T}: Type to which the sprinkling coordinates will be converted (default is Float32).\n\nReturns\n\nA tuple (cset, sprinkling, chebyshev_coefs) where:\ncset: The generated causal set.\nsprinkling: The list of sprinkled points.\nchebyshev_coefs: The matrix of Chebyshev coefficients used to construct the manifold.\n\nThrows\n\nArgumentError if npoints <= 0\nArgumentError if order <= 0\nArgumentError if r <= 1\nArgumentError if d != 2. Currently, only 2D is supported.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.gaussian_dist_cuts","page":"QuantumGrav.jl","title":"QuantumGrav.gaussian_dist_cuts","text":"gaussian_dist_cuts(N, n, σ; rng=Random.GLOBAL_RNG)\n\nCreate cut points between layers drawn from a Gaussian distribution centered on equal partition sizes.\n\nInputs:     N :: Int — total number of elements to partition     n :: Int — number of layers     σ :: Float64 — standard deviation for Gaussian offsets from equal partitioning     rng :: AbstractRNG — random number generator (default: Random.GLOBAL_RNG)\n\nReturns:     cuts :: Vector{Int} — list of cut indices separating layers (length n-1)\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.create_random_layered_causet","page":"QuantumGrav.jl","title":"QuantumGrav.create_random_layered_causet","text":"layered_causet(N, n; p=0.5, rng=Random.GLOBAL_RNG)\n\nGenerate an n-layered causal set with N elements, randomly partitioned into n layers, with each potential link between adjacent layers included independently with probability p. Layer sizes are drawn from a Gaussian distribution  centered around equal partition size.\n\nInputs:     N :: Int — total number of elements in the causal set     n :: Int — number of layers     p :: Float64 — probability for a link to exist between elements in successive layers     rng :: AbstractRNG — random number generator to use (default: Random.GLOBALRNG)     standarddeviation :: Float64: standard deviation of the Gaussian around equal partitioning\n\nReturns:     tcg :: BitArrayCauset - randomly produced layered causal set     atomsperlayer :: Vector{Int64} - number of atoms per layer sorted from past to future\n\nNotes:     The standard_deviation keyword controls the spread of the Gaussian in partitioning; if not provided, defaults to 0.1 * N / n.     Layer sizes are resampled until within bounds to avoid bias from clamping.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.sample_bitarray_causet_by_connectivity","page":"QuantumGrav.jl","title":"QuantumGrav.sample_bitarray_causet_by_connectivity","text":"Sample a causet with given connectivity using a Markov Chain Monte Carlo method with adaptive number of edge flips.\n\nParameters\n\nsize::Int64: Number of nodes in the causet.\nconnectivity_goal::Float64: Target connectivity ratio for the causet.\nmarkov_steps::Int64: Number of Markov chain steps to perform.\nrng::AbstractRNG: Random number generator instance.\nflips_param::Float64: Parameter of algorithm that relates distance from connectivity goal with number of edge flips.\nrel_tol::Float64: Relative distance between connectivity and connectivity_goal beyond which the algorithm stops.\nabs_tol::Float64: Absolute distance between connectivity and connectivity_goal beyond which the algorithm stops.\nacceptance::Float64: Acceptance parameter for the Metropolis criterion.\n\nReturns\n\nA bitarray causet sampled according to the connectivity goal.\nA boolean indicating whether the sampling was successful.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.random_causet_by_connectivity_distribution","page":"QuantumGrav.jl","title":"QuantumGrav.random_causet_by_connectivity_distribution","text":"Sample a causet of given size with connectivity goal drawn from a specified distribution.\n\nThis function draws a connectivity goal value from the provided distribution dist and then  samples a causet using Markov Chain Monte Carlo with adaptive edge flips to approximate this connectivity.\n\nInputs\n\nsize::Int64: Number of nodes in the causet.\ndist::Distributions.Distribution: Distribution from which to draw the connectivity goal.\nmarkov_steps::Int64: Number of Markov chain steps to perform.\nrng::Random.AbstractRNG: Random number generator instance.\n\nKeyword Arguments\n\nrel_tol::Union{Float64,Nothing}: Relative tolerance for stopping criterion.\nabs_tol::Union{Float64,Nothing}: Absolute tolerance for stopping criterion.\nacceptance::Float64: Acceptance parameter for the Metropolis criterion.\n\nReturns\n\nA tuple containing:\nCausalSets.BitArrayCauset: The sampled causet as a bitarray.\nBool: A boolean indicating whether the sampling was successful within the tolerance.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.generate_grid_from_brillouin_cell","page":"QuantumGrav.jl","title":"QuantumGrav.generate_grid_from_brillouin_cell","text":"generate_grid_from_brillouin_cell(num_atoms, edges; origin=nothing) -> Vector{CausalSets.Coordinates{N}}\n\nConstruct an N‑dimensional regular grid of approximately num_atoms points that fills the Brillouin cell spanned by N edge vectors edges.\n\nArguments\n\nnum_atoms::Int: desired number of grid points (≥1). The implementation lays down a Cartesian parameter grid with ≈ num_atoms candidates and trims to exactly num_atoms.\nedges::NTuple{N,CausalSets.Coordinates{N}}: the N spanning edge vectors of a parallelepiped cell. Points are of the form x = origin + sum_i t_i * edges[i] with t_i ∈ [0,1].\norigin: optional NTuple{N,Float64} origin (vertex) of the cell. If nothing, zero is used.\n\nReturns\n\nVector{CausalSets.Coordinates{N}}: grid points inside the cell, ordered lexicographically in the parameter tuple (t₁,…,t_N), trimmed to length num_atoms.\n\nErrors\n\nThrows ArgumentError if num_atoms < 1.\nThrows ArgumentError if the edges are not linearly independent (near‑zero determinant).\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.generate_grid_2d","page":"QuantumGrav.jl","title":"QuantumGrav.generate_grid_2d","text":"generate_grid_2d(num_atoms, lattice; a=1.0, b=0.5, gamma_deg=60.0, rotate_deg=nothing, origin=(0.0,0.0))\n    -> Vector{CausalSets.Coordinates{2}}\n\nWrapper that builds a 2D Bravais cell from a lattice name and calls generate_grid_from_brillouin_cell to return num_atoms points.\n\nSupported lattice names (case‑insensitive, with aliases):\n\n\"square\", \"quadratic\":         edges ((a,0), (0,a))\n\"rectangular\":                  edges ((a,0), (0,b))\n\"centered-rectangular\", \"rhombic\", \"c-rect\": primitive edges ((a/2,b/2), (a/2,-b/2))\n\"hexagonal\", \"triangular\":      edges ((a,0), (a/2, a*sqrt(3)/2))\n\"oblique\", \"monoclinic\":       edges ((a,0), (b*cosγ, b*sinγ)), with γ = gamma_deg (degrees)\n\nKeywords\n\na::Float64=1.0, b::Float64=0.5: lattice constants (for square, only a is used).\ngamma_deg::Float64=60.0: angle (degrees) between edges for the oblique lattice.\nrotate_deg=nothing: rotation (degrees) applied to the basis before grid generation. If nothing, an automatic rotation aligns the net growth direction e₁+e₂ with +y.\norigin::CausalSets.Coordinates{2}=(0.0,0.0): origin (vertex) of the cell.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.create_grid_causet_2D","page":"QuantumGrav.jl","title":"QuantumGrav.create_grid_causet_2D","text":"create_grid_causet_2D(size, lattice, manifold; \n                      type=Float32, a=1.0, b=0.5, \n                      gamma_deg=60.0, rotate_deg=nothing, \n                      origin=(0.0, 0.0)) \n    -> Tuple{CausalSets.BitArrayCauset, Bool, Matrix{T}}\n\nConstruct a 2D grid of size points based on the given Bravais lattice, sort them by the time function of manifold, and build a BitArrayCauset from the resulting pseudo‑sprinkling.\n\nArguments\n\nsize::Int: number of atoms to generate (≥ 1).\nlattice::AbstractString: name of the 2D Bravais lattice. Supported names (case-insensitive):   • \"square\", \"quadratic\" → edges ((a,0), (0,a))   • \"rectangular\" → edges ((a,0), (0,b))   • \"centered-rectangular\", \"rhombic\", \"c-rect\" → edges ((a/2,b/2), (a/2,-b/2))   • \"hexagonal\", \"triangular\" → edges ((a,0), (a/2, asqrt(3)/2))   • \"oblique\", \"monoclinic\" → edges ((a,0), (bcos(γ), b*sin(γ))) with γ = gamma_deg\nmanifold::CausalSets.AbstractManifold{2}: 2D manifold defining the causal structure on the grid.\n\nKeywords\n\ntype::Type{T}=Float32: numeric type used for the returned coordinate matrix.\na::Float64=1.0, b::Float64=0.5: lattice constants.\ngamma_deg::Float64=60.0: angle between lattice vectors (for \"oblique\"/\"monoclinic\" only).\nrotate_deg=nothing: if set, rotate the lattice by the given angle (in degrees). If nothing, automatically aligns (e₁ + e₂) with the positive y-axis.\norigin::Tuple{Float64,Float64}: coordinate of the origin vertex.\n\nReturns\n\nTuple{BitArrayCauset, Bool, Matrix{T}}:    \nBitArrayCauset the constructed causet,\nBool - true immitates the \"converged\" return option for random_csets\nMatrix{T} - the coordinate matrix of atoms on the grid, immitating the pseudo-sprinkling in random_csets\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.create_grid_causet_2D_polynomial_manifold","page":"QuantumGrav.jl","title":"QuantumGrav.create_grid_causet_2D_polynomial_manifold","text":"create_grid_causet_2D_polynomial_manifold(size, lattice, rng, order, r;\n                                          type=Float32, a=1.0, b=0.5, \n                                          gamma_deg=60.0, rotate_deg=nothing, \n                                          origin=(0.0, 0.0)) \n    -> Tuple{CausalSets.BitArrayCauset, Bool, Matrix{T}}\n\nConstruct a 2D grid of size points based on the given Bravais lattice, generate a random 2D polynomial time function, and build a BitArrayCauset from the resulting pseudo-sprinkling order.\n\nArguments\n\nsize::Int: number of atoms to generate (≥ 1).\nlattice::AbstractString: name of the 2D Bravais lattice. Supported names (case-insensitive):   • \"square\", \"quadratic\" → edges ((a,0), (0,a))   • \"rectangular\" → edges ((a,0), (0,b))   • \"centered-rectangular\", \"rhombic\", \"c-rect\" → edges ((a/2,b/2), (a/2,-b/2))   • \"hexagonal\", \"triangular\" → edges ((a,0), (a/2, asqrt(3)/2))   • \"oblique\", \"monoclinic\" → edges ((a,0), (bcos(γ), b*sin(γ))) with γ = gamma_deg\nrng::Random.AbstractRNG: random number generator for coefficient sampling.\norder::Int: order of the polynomial (≥ 1).\nr::Float64: exponential decay rate for Chebyshev coefficients.\n\nKeywords\n\ntype::Type{T}=Float32: numeric type used for the returned coordinate matrix.\na::Float64=1.0, b::Float64=0.5: lattice constants.\ngamma_deg::Float64=60.0: angle between lattice vectors (for \"oblique\"/\"monoclinic\" only).\nrotate_deg=nothing: if set, rotate the lattice by the given angle (in degrees). If nothing, automatically aligns (e₁ + e₂) with the positive y-axis.\norigin::Tuple{Float64,Float64}: coordinate of the origin vertex.\n\nReturns\n\nTuple{BitArrayCauset, Bool, Matrix{T}}:    \nBitArrayCauset — the constructed causet from the polynomial time ordering,\nBool — always true, for compatibility\nMatrix{T} — coordinate matrix of atoms on the grid.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.BranchedManifoldCauset","page":"QuantumGrav.jl","title":"QuantumGrav.BranchedManifoldCauset","text":"BranchedManifoldCauset{N, M} <: CausalSets.AbstractCauset\n\nA causal set embedded in a background manifold with topological branch points (cuts), supporting finite and boundary-connecting cut segments.\n\nType Parameters\n\nN: Dimensionality of the spacetime.\nM: Type of the background manifold (a subtype of CausalSets.AbstractManifold{N}).\n\nFields\n\natom_count::Int64: Number of elements (atoms) in the causet.\nmanifold::M: The background manifold defining the causal structure.\nbranch_point_info::Tuple{Vector{Coordinates{N}}, Vector{Tuple{Coordinates{N}, Coordinates{N}}}}:\nFirst element: Single branch points (each induces a timelike topological cut extending to the boundary).\nSecond element: Finite topological cuts (segments between two points).\nsprinkling::Vector{Coordinates{N}}: Coordinates of the sprinkled points, typically sorted by time.\n\nPurpose\n\nEncodes both the geometry and topology of the geometry underlying the causal set, allowing causal relations to be modified by finite or vertical topological obstructions. Used for modeling spacetimes with topology change or nontrivial causal structure.\n\nNotes\n\nThis type is interoperable with CausalSets.in_past_of_unchecked, BitArrayCauset, and related methods.\nVertical cuts (from single branch points) are interpreted as timelike obstructions to causal curves.\nFinite cuts can be timelike, spacelike, or null and may intersect.\n\nExample\n\nimport CausalSets\nmanifold = CausalSets.MinkowskiManifold{2}()\nsprinkling = [CausalSets.Coordinates{2}((0.1, 0.0)), CausalSets.Coordinates{2}((0.9, 0.0))]\nsingle_branch_points = [CausalSets.Coordinates{2}((0.5, 0.0))]\nfinite_cuts = [(CausalSets.Coordinates{2}((0.3, -1.0)), CausalSets.Coordinates{2}((0.3, 1.0)))]\ncauset = BranchedManifoldCauset(manifold, (single_branch_points, finite_cuts), sprinkling)\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.make_branched_manifold_cset","page":"QuantumGrav.jl","title":"QuantumGrav.make_branched_manifold_cset","text":"make_branched_manifold_cset(\n    npoints::Int64,\n    n_vertical_cuts::Int64,\n    n_finite_cuts::Int64,\n    rng::AbstractRNG,\n    order::Int64,\n    r::Float64;\n    d::Int64 = 2,\n    tolerance::Float64 = 1e-12,\n    type::Type{T} = Float32\n) -> Tuple{\n    CausalSets.BitArrayCauset,\n    Vector{Coordinates{2}},\n    Tuple{Vector{Coordinates{2}}, Vector{Tuple{Coordinates{2}, Coordinates{2}}}},\n    Matrix{T}\n}\n\nGenerate a branched causal set in a random polynomial manifold with timelike boundary-connecting and finite topological cuts.\n\nPurpose\n\nThis function builds a toy model of a branched spacetime:\n\nA random 2D polynomial manifold is generated from Chebyshev coefficients with exponential decay.\nA sprinkling of npoints events is placed into the manifold.\nRandom vertical cuts (from single branch points extending upward in time) and finite cuts (segments between two points) are introduced.\nPoints lying too close to cuts are filtered out.\nA BranchedManifoldCauset and its causal matrix (BitArrayCauset) are constructed.\n\nArguments\n\nnpoints::Int64: Number of sprinkled points. Must be > 0.\nn_vertical_cuts::Int64: Number of vertical cuts (≥ 0).\nn_finite_cuts::Int64: Number of finite cuts (≥ 0).\nrng::AbstractRNG: Random number generator.\norder::Int64: Order of the Chebyshev expansion (must be > 0).\nr::Float64: Decay base for Chebyshev coefficients (must be > 1).\nd::Int64: Dimension of the spacetime. Only d = 2 is supported (default).\ntolerance::Float64: Minimal distance for filtering points too close to cuts and for computing spacetime distances (default: 1e-12).\ntype::Type{T}: Numeric type for the returned Chebyshev coefficient matrix (default: Float32).\n\nReturns\n\nA 4-tuple (cset, sprinkling, branch_point_info, chebyshev_coefs):\n\ncset::BitArrayCauset: The causal set with branch cuts encoded.\nsprinkling::Vector{Coordinates{2}}: The filtered sprinkled points.\nbranch_point_info::Tuple{Vector{Coordinates{2}}, Vector{Tuple{Coordinates{2}, Coordinates{2}}}}:\nSingle branch points (for timelike boundary-connecting cuts),\nFinite cut segments.\nchebyshev_coefs::Matrix{T}: Chebyshev coefficients of the random polynomial manifold.\n\nThrows\n\nArgumentError if any of:\nnpoints ≤ 0\nn_vertical_cuts < 0\nn_finite_cuts < 0\norder ≤ 0\nr ≤ 1\nd ≠ 2\ntolerance ≤ 0\n\nExample\n\n```julia using Random, CausalSets rng = MersenneTwister(1234) cset, sprinkling, branchinfo, coefs =     makebranchedmanifoldcset(50, 2, 3, rng, 5, 2.0)\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.merge_csets","page":"QuantumGrav.jl","title":"QuantumGrav.merge_csets","text":"mergecsets(cset1Raw::AbstractCauset, cset2Raw::AbstractCauset, linkprobability::Float64)      -> BitArrayCauset\n\nMerge two causal sets cset1Raw and cset2Raw into a single causal set by placing them on the diagonal of a larger causet and connecting them with random links in the upper-right block with probability link_probability. Transitive closure is applied after merging.\n\nNote: The actual degree of connectivity is underestimated unless link_probability is 0 or 1, since transitive completion will overwrite the sparsity induced by random linking.\n\nArguments\n\ncset1Raw: First input causal set (converted to BitArrayCauset if necessary)\ncset2Raw: Second input causal set (converted to BitArrayCauset if necessary)\nlink_probability: Probability with which to add links from cset1Raw to cset2Raw (must be in [0, 1])\n\nReturns\n\nA BitArrayCauset representing the merged and transitively closed causal set\n\nThrows\n\nArgumentError if link_probability is not in the interval [0, 1]\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.insert_cset","page":"QuantumGrav.jl","title":"QuantumGrav.insert_cset","text":"insertcset(cset1Raw::AbstractCauset, cset2Raw::AbstractCauset, linkprobability::Float64; rng::AbstractRNG=Random.GLOBAL_RNG, position::Union{Nothing, Int64}=nothing)      -> BitArrayCauset\n\nInsert cset2Raw into cset1Raw at a random or specified position. All atoms are reindexed accordingly. Random links are added across the insertion boundary — i.e. from atoms before the inserted block to atoms inside it, and from the inserted block to atoms after it — with probability link_probability. Transitive closure is applied after insertion.\n\nArguments\n\ncset1Raw: First input causal set (converted to BitArrayCauset if necessary)\ncset2Raw: Second input causal set (converted to BitArrayCauset if necessary)\nlink_probability: Probability with which to add links across the insertion boundary (must be in [0, 1])\nrng: Random number generator (default: Random.GLOBAL_RNG)\nposition: Optional insertion index in 0:n1; if nothing, insertion is random\n\nReturns\n\nA BitArrayCauset representing the merged and transitively closed causal set\n\nThrows\n\nArgumentError if link_probability is not in the interval [0, 1]\nArgumentError if position is not in the valid range 0 ≤ position ≤ atom_count of cset1Raw\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.insert_KR_into_manifoldlike","page":"QuantumGrav.jl","title":"QuantumGrav.insert_KR_into_manifoldlike","text":"insertKRintomanifoldlike(npoints::Int64, order::Int64, r::Float64, linkprobability::Float64;                              rng::AbstractRNG=Random.GLOBAL_RNG, position::Union{Nothing, Int64}=nothing,                             d::Int64=2, type::Type=Float32, p::Float64=0.5)     -> Tuple{BitArrayCauset, Bool, Matrix{T}}\n\nGenerate a manifoldlike causal set and insert into it a KR-order (random layered) causal set. The insertion point is chosen randomly (or specified via position). Random links are added across the insertion boundary with probability link_probability. Transitive closure is applied to ensure consistency.\n\nReturns the merged causet, a dummy true, and the coordinate matrix used for the manifoldlike causet.\n\nArguments\n\nnpoints: Total number of elements in the resulting causal set (may be off by 1 due to rounding errors)\norder: Sprinkling order for the manifoldlike causet\nr: Interaction scale for manifoldlike causet generation\nlink_probability: Probability for adding links across the insertion boundary (must be in [0, 1])\nrng: Random number generator (default: Random.GLOBAL_RNG)\nn2_rel: Size of KR order relative to total size of resulting causet\nposition: Optional insertion index in 0:npoints; if nothing, insertion is random\nd: Dimension of the manifoldlike causal set (default: 2)\ntype: Coordinate type (default: Float32)\np: Link-probability within KR-order (default: 0.5)\n\nReturns\n\nA tuple (cset, true, coords) where:\ncset is the merged and transitively completed BitArrayCauset\ntrue is a placeholder flag\ncoords is a Matrix{T} of coordinates used for the manifoldlike causet\n\nThrows\n\nArgumentError if link_probability is not in the interval [0, 1]\nArgumentError if position is not in the valid range 0 ≤ position ≤ npoints\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.destroy_manifold_cset","page":"QuantumGrav.jl","title":"QuantumGrav.destroy_manifold_cset","text":"destroy_manifold_cset(size::Int64, num_flips::Int64, rng::Random.AbstractRNG, order::Int64, r::Float64; d::Int64=2, type::Type{T}=Float32) -> CausalSets.BitArrayCauset\n\nStarts from a manifold-like causal set and destroys its manifoldlike structure by flipping a given number of randomly chosen edges, then applies transitive closure.\n\nArguments\n\nsize::Int64: The number of elements in the causal set.\nnum_flips::Int64: The number of edges to flip at random in the set (each flip toggles the presence/absence of a relation).\nrng::Random.AbstractRNG: Random number generator to use for reproducibility.\norder::Int64: The order parameter passed to the manifold causal set generator.\nr::Float64: The sprinkling density or radius parameter for the manifold causal set.\n\nKeyword Arguments\n\nd::Int64=2: The dimension of the spacetime manifold to sprinkle into (default: 2).\ntype::Type{T}=Float32: The numeric type for coordinates (default: Float32).\n\nReturns\n\nCausalSets.BitArrayCauset: The resulting causal set as a BitArrayCauset, which may be non-manifoldlike after random edge flips.\nsprinkling: The sprinkling of the geometry underlying the destroyed causal set.\nchebyshev_coefs: The Chebyshev coefficients of the geometry underlying the destroyed causal set.\n\nThrows\n\nArgumentError: if num_flips < 1.\nArgumentError: if num_flips > size*(size-1)/2.\n\nBehavior\n\nThis function generates a manifold-like causal set using make_polynomial_manifold_cset, then randomly selects num_flips pairs of elements (edges) and flips their causal relation (adding or removing the edge). After all flips, it applies transitive closure to ensure the causality structure is consistent, and returns the final causal set as a BitArrayCauset.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.Ricci_scalar_2D","page":"QuantumGrav.jl","title":"QuantumGrav.Ricci_scalar_2D","text":"Ricci_scalar_2D(\n    coefs::Array{Float64, 2}, \n    position::CausalSets.Coordinates{2}; \n    derivation_matrix::Union{Nothing, Array{Float64, 2}}=nothing\n) -> Float64\n\nComputes the Ricci scalar curvature at a given position for a 2D Lorentzian manifold in conformally flat slicing with conformal factor expressed as Chebyshev expansion.\n\nArguments\n\ncoefs::Array{Float64, 2}: A matrix of Chebyshev coefficients representing the conformal factor expanded in two variables.\nposition::CausalSets.Coordinates{2}: A 2D coordinate at which to evaluate the Ricci scalar.\n\nKeyword Arguments\n\nderivation_matrix1::Union{Nothing, Array{Float64, 2}}=nothing: Optional precomputed Chebyshev derivation matrix for first derivatives to speed up computation.\nderivation_matrix2::Union{Nothing, Array{Float64, 2}}=nothing: Optional precomputed Chebyshev derivation matrix for second derivatives to speed up computation.\n\nReturns\n\nFloat64: The Ricci scalar curvature evaluated at the given position.\n\nThrows\n\nArgumentError: if the coefficient matrix is not a square matrix. Asymmetric orders are not supported (but can be emulated by adding 0s in the coefficient matrix).\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.Ricci_scalar_2D_of_sprinkling","page":"QuantumGrav.jl","title":"QuantumGrav.Ricci_scalar_2D_of_sprinkling","text":"Ricci_scalar_2D_of_sprinkling(\n    coefs::Array{Float64, 2},\n    sprinkling::Vector{CausalSets.Coordinates{2}};\n    derivation_matrix1::Union{Nothing, Array{Float64, 2}}=nothing,\n    derivation_matrix2::Union{Nothing, Array{Float64, 2}}=nothing,\n) -> Vector{Float64}\n\nComputes the Ricci scalar curvature at multiple points (sprinkling) for a 2D Lorentzian manifold in conformally flat slicing with conformal factor expressed as Chebyshev expansion.\n\nArguments\n\ncoefs::Array{Float64, 2}: A matrix of Chebyshev coefficients representing the conformal factor expanded in two variables.\nsprinkling::Vector{CausalSets.Coordinates{2}}: A vector of 2D coordinates at which to evaluate the Ricci scalar.\n\nKeyword Arguments\n\nderivation_matrix1::Union{Nothing, Array{Float64, 2}}=nothing: Optional precomputed Chebyshev derivation matrix for first derivatives.\nderivation_matrix2::Union{Nothing, Array{Float64, 2}}=nothing: Optional precomputed Chebyshev derivation matrix for second derivatives.\n\nReturns\n\nVector{Float64}: A vector of Ricci scalar curvature values evaluated at the given points.\n\nThrows\n\nArgumentError: if the coefficient matrix is not a square matrix.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.PolynomialCsetMaker","page":"QuantumGrav.jl","title":"QuantumGrav.PolynomialCsetMaker","text":"PolynomialCsetMaker\n\nCausal set maker for a polynomial manifold.\n\nFields:\n\norder_distribution::Distributions.Distribution: distribution of polynomial orders\nr_distribution::Distributions.Distribution: distribution of exponential decay exponents\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.RandomCsetMaker","page":"QuantumGrav.jl","title":"QuantumGrav.RandomCsetMaker","text":"RandomCsetMaker\n\nCausal set maker for a random causal set.\n\nFields:\n\ncdistr::Distributions.Distribution: distribution of connectivity goals\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.LayeredCsetMaker","page":"QuantumGrav.jl","title":"QuantumGrav.LayeredCsetMaker","text":"LayeredCsetMaker\n\nCausal set maker for a layered causal set.\n\nFields:\n\nconnectivity_distribution::Distributions.Distribution: distribution of connectivity goals\nstddev_distribution::Distributions.Distribution: distribution of standard deviations\nlayer_distribution::Distributions.Distribution: distribution of layer counts\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.DestroyedCsetMaker","page":"QuantumGrav.jl","title":"QuantumGrav.DestroyedCsetMaker","text":"DestroyedCsetMaker\n\nCausal set maker for a destroyed causal set, which has a set of edges flipped in a polynomial causal set.\n\nFields:\n\norder_distribution::Distributions.Distribution: distribution of order values\nr_distribution::Distributions.Distribution: distribution of r values\nflip_distribution::Distributions.Distribution: distribution of flip values\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.GridCsetMakerPolynomial","page":"QuantumGrav.jl","title":"QuantumGrav.GridCsetMakerPolynomial","text":"GridCsetMakerPolynomial\n\nCreate a new `grid` causal set maker object from the config dictionary for polynomial spacetimes.\n\nFields:\n\n- grid_distribution::Distributions.Distribution: TODO\n- rotate_distribution::Distributions.Distribution: TODO\n- order_distribution::Distributions.Distribution: TODO\n- r_distribution::Distributions.Distribution: TODO\n- grid_lookup::Dict: TODO\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.MergedCsetMaker","page":"QuantumGrav.jl","title":"QuantumGrav.MergedCsetMaker","text":"MergedCsetMaker\n\nCausal set maker from a given configuration dictionary.\n\nFields:\n\nlink_prob_distribution::Distributions.Distribution: distribution of link probabilities\norder_distribution::Distributions.Distribution: distribution of order values\nr_distribution::Distributions.Distribution: distribution of r values\nn2_rel_distribution::Distributions.Distribution: distribution of n2 relative values\nconnectivity_distribution::Distributions.Distribution: distribution of connectivity values\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.ComplexTopCsetMaker","page":"QuantumGrav.jl","title":"QuantumGrav.ComplexTopCsetMaker","text":"ComplexTopCsetMaker\n\nA callable struct to produce complex topology csets with various causality-cutting 'lines' in a 2D manifold\n\nFields:\n\nvertical_cut_distr::Distributions.Distribution: Distribution to draw the number of vertical (time direction) cuts from\nfinite_cut_distr::Distributions.Distribution: Distribution to draw the number of mixed direction cuts from\norder_distribution::Distributions.Distribution: Distribution to draw the number of orders for the polynomial expansion from\nr_distribution::Distributions.Distribution: Distribution to draw the decay exponent for the orders in the polynomial expansion from\ntol::Float64: Floating point comparison tolerance\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.CsetFactory","page":"QuantumGrav.jl","title":"QuantumGrav.CsetFactory","text":"CsetFactory\n\nThe CsetFactory struct serves as a container for generating causal sets (csets). It holds the configuration, random number generator, and distribution information required to create csets, and provides access to specialized factory functions for different cset types.\n\nFields:\n\nnpoint_distribution::Distributions.Distribution: Distribution object for drawing number of elements in a cset\nconf::Dict: config dictionary\nrng::Random.AbstractRNG: random number generator to use\ncset_makers::Dict: dict to hold all the different cset factory methods\n\n\n\n\n\n","category":"type"},{"location":"#QuantumGrav.encode_csettype","page":"QuantumGrav.jl","title":"QuantumGrav.encode_csettype","text":"encode_csettype(config)\n\nEncode known cset types into numeric scheme.\n\n\n\n\n\n","category":"constant"},{"location":"#QuantumGrav.prepare_dataproduction","page":"QuantumGrav.jl","title":"QuantumGrav.prepare_dataproduction","text":"prepare_dataproduction(config::Dict{String, Any}, funcs_to_copy::Vector{Any})::Tuple{str, Zarr.DirectoryStore}\n\nPrepare the data production process from the config dict supplied.\n\ncreate a target directory\ncopy over the source files of the passed functions. The user has to select these based on their importance for data production and whether they should be retained together with the data in the target directory\nstore the git info of the QuantumGrav package (branch, tree hash, source) used\nsave the config file, augmented with git info,  to the target directory\ncreate a zarr directorystore based on the config file.\n\nArguments\n\nconfig::Dict{String, Any} Config file defining the data generation system funcstocopy::Vector{Any} Functions which are to be used and whose source files are to be copied to be retained\n\nReturns\n\nTuple{String, Zarr.DirectoryStore} The path to the output file and the output file itself.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.copy_sourcecode","page":"QuantumGrav.jl","title":"QuantumGrav.copy_sourcecode","text":"copy_sourcecode(funcs_to_copy::Vector{Any}, targetpath::String)\n\nCopy the sourcecode files of the functions in the arguments to a targetpath.\n\nArguments:\n\nfuncstocopy::Vector list of functions to copy the sourcecode files of targetpath::String local path to copy the files to\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.get_git_info!","page":"QuantumGrav.jl","title":"QuantumGrav.get_git_info!","text":"get_git_info!(config::Dict{String, Any})\n\nGet git info (branch, source, tree_hash) of the QuantumGrav package\n\nArguments\n\nconfig::Dict{String, Any} Config dictionary to put the git data into\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.dict_to_zarr","page":"QuantumGrav.jl","title":"QuantumGrav.dict_to_zarr","text":"dict_to_zarr(file_or_group::Union{Zarr.DirectoryStore, Zarr.ZGroup}, data::Dict{String, Any}, compressor_kwargs = Dict(:clevel => 9, :cname => \"lz4\", :shuffle => 2), chunking_strategy::Union{Dict{String, Function}, Function, Nothing} = default_chunks)\n\nRecursively write a nested dictionary to a Zarr group.\n\nArguments:\n\nfile_or_group: Zarr DirectoryStore or Group to write the data to\ndata: Nested dictionary to write\ncompressor_kwargs: Compression options for the arrays\nchunking_strategy: Chunking strategy for the arrays. If you want not chunking, use 'nothing' here.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.make_adj","page":"QuantumGrav.jl","title":"QuantumGrav.make_adj","text":"make_adj(c::CausalSets.AbstractCauset, type::Type{T}) -> SparseMatrixCSC{T}\n\nCreates an adjacency matrix from a causet's future relations.\n\nArguments\n\nc::CausalSets..AbstractCauset: The causet object containing future relations\ntype::Type{T}: Numeric type for the adjacency matrix entries\n\nReturns\n\nSparseMatrixCSC{T}: Sparse adjacency matrix representing the causal structure\n\nNotes\n\nConverts the causet's future_relations to a sparse matrix format by horizontally concatenating, transposing, and converting to the specified type.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.max_pathlen","page":"QuantumGrav.jl","title":"QuantumGrav.max_pathlen","text":"maxpathlen(adj_matrix, topo_order::Vector{Int}, source::Int) -> Int32\n\nCalculates the maximum path length from a source node in a directed acyclic graph.\n\nArguments\n\nadj_matrix: Adjacency matrix representing the directed graph\ntopo_order::Vector{Int}: Topologically sorted order of vertices\nsource::Int: Source vertex index to calculate distances from\n\nReturns\n\nInt32: Maximum finite distance from the source node, or 0 if no paths exist\n\nNotes\n\nUses dynamic programming with topological ordering for efficient longest path computation. Processes vertices in topological order to ensure optimal substructure property. Returns 0 if no finite distances exist from the source.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.transitive_reduction!","page":"QuantumGrav.jl","title":"QuantumGrav.transitive_reduction!","text":"transitive_reduction!(mat::AbstractMatrix)\n\nCompute the transitive reduction of the input matrix, such that only connections (i,j) remain that have a max pathlen of 1. This assumes that the input matrix is upper triangular, i.e., a topologically ordered DAG. If that is not the case, the results will be incorrect.\n\nArguments\n\nmat::AbstractMatrix: The input matrix to compute the transitive reduction on\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.make_pseudosprinkling","page":"QuantumGrav.jl","title":"QuantumGrav.make_pseudosprinkling","text":"make_pseudosprinkling(n, d, box_min, box_max, type; rng) -> Vector{Vector{T}}\n\nGenerates random points uniformly distributed in a d-dimensional box.\n\nArguments\n\nn::Int64: Number of points to generate\nd::Int64: Dimension of each point\nbox_min::Float64: Minimum coordinate value\nbox_max::Float64: Maximum coordinate value\ntype::Type{T}: Numeric type for coordinates\nrng: Random number generator (default: Xoshiro(1234))\n\nReturns\n\nVector{Vector{T}}: Vector of n points, each point is a d-dimensional vector\n\nNotes\n\nUsed for creating pseudo-sprinklings in PseudoManifold when geometric manifold sprinkling is not applicable.\n\n\n\n\n\n","category":"function"},{"location":"#QuantumGrav.validate_config","page":"QuantumGrav.jl","title":"QuantumGrav.validate_config","text":" validate_config(schema, cfg)::Nothing\n\nValidate a config using a json schema it must adhere to\n\nArguments\n\nschema: json schema to test against\nconfig: config dictionary to test\n\nReturns\n\nnothing\n\nthrows\n\nArgument error: if validation fails\n\n\n\n\n\n","category":"function"}]
}
